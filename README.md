# Maison Lavaux Perfumery

## Introduction

Maison Lavaux is a fully functional e-commerce platform specialising in boutique perfumes. Inspired by the fictitious luxury brand from the hit series Emily in Paris, Maison Lavaux offers a seamless shopping experience for customers seeking exclusive and sophisticated fragrances. Based on the Boutique Ado skeleton, the platform has been extensively modified and enhanced to deliver a unique and refined shopping experience. With a user-friendly interface, secure online payments, and a stylish design, Maison Lavaux is your go-to destination for luxury perfumes.

INSERT SCREENSHOT

View the live version of the website at [Maison Lavaux](https://maison-lavaux-ebcf574677ab.herokuapp.com/).

## User Experience

### Initial Discussion

### Epics

In website development, epics are high-level objectives that represent major areas of functionality or user needs. Each epic encompasses multiple user stories, providing structure and clarity in the development process. They ensure all work aligns with the overarching goals of the project and facilitate tracking progress across related features. These are the epics I chose for my project:

1. User Experience (UX) [#10](https://github.com/jdohertydev/maison_lavaux/issues/10)
2. Product Browsing and Reviews [#11](https://github.com/jdohertydev/maison_lavaux/issues/11)
3. Checkout and Payment [#12](https://github.com/jdohertydev/maison_lavaux/issues/12)
4. Messaging and Communication [#13](https://github.com/jdohertydev/maison_lavaux/issues/13)
5. Admin Product Management [#14](https://github.com/jdohertydev/maison_lavaux/issues/14)
6. Sales and Analytics [#15](https://github.com/jdohertydev/maison_lavaux/issues/15)

### User Stories

User stories are short, simple descriptions of a feature or functionality told from the perspective of the end user. They help ensure the development process remains user-focused, aligning each task with specific user needs and goals. Below are the user stories I created for my project:

### Owner/Admin and Developer Goals
- As an admin, I can assign products to specific categories so that users can find them more easily during browsing. [#53](https://github.com/jdohertydev/maison_lavaux/issues/53)
- As an admin, I can temporarily hide products from the storefront so that users don’t see items that are being updated or out of stock. [#54](https://github.com/jdohertydev/maison_lavaux/issues/54)
- As an admin, I can view a summary of product inventory so that I can monitor stock levels easily. [#52](https://github.com/jdohertydev/maison_lavaux/issues/52)
- As an admin, I can upload, update, or delete product images so that products are visually appealing and well-represented. [#51](https://github.com/jdohertydev/maison_lavaux/issues/51)
- As an admin, I can edit existing product details (e.g., name, price, description, stock) so that the catalogue stays accurate and up-to-date. [#49](https://github.com/jdohertydev/maison_lavaux/issues/49)
- As an admin, I can add new products to the catalogue so that users can see and purchase the latest items available. [#48](https://github.com/jdohertydev/maison_lavaux/issues/48)
- As an admin, I can delete products from the catalogue so that unavailable items no longer appear on the site. [#50](https://github.com/jdohertydev/maison_lavaux/issues/50)
- As an admin, I can sort products in the admin panel by various criteria (e.g., name, price, stock level) so that I can manage the catalogue more efficiently. [#55](https://github.com/jdohertydev/maison_lavaux/issues/55)
- As an admin, I can compare the performance of multiple products side by side so that I can make informed inventory or marketing decisions. [#62](https://github.com/jdohertydev/maison_lavaux/issues/62)
- As an admin, I can sort analytics data (e.g., revenue, views, purchases) so that I can prioritise metrics most relevant to my goals. [#61](https://github.com/jdohertydev/maison_lavaux/issues/61)
- As an admin, I can view a list of the top-selling products so that I can focus on promoting high-performing items. [#60](https://github.com/jdohertydev/maison_lavaux/issues/60)
- As an admin, I can filter sales and analytics data by specific time periods (e.g., weekly, monthly) so that I can assess trends and plan strategies effectively. [#59](https://github.com/jdohertydev/maison_lavaux/issues/59)
- As an admin, I can analyse revenue trends over time so that I can evaluate overall business performance. [#58](https://github.com/jdohertydev/maison_lavaux/issues/58)
- As an admin, I can track the number of purchases for each product so that I can determine which items are most popular. [#57](https://github.com/jdohertydev/maison_lavaux/issues/57)
- As an admin, I can view the number of page views for each product so that I can identify which products attract the most interest. [#56](https://github.com/jdohertydev/maison_lavaux/issues/56)
- As an admin, I can view all messages submitted by users in a structured format so that I can respond to inquiries efficiently. [#44](https://github.com/jdohertydev/maison_lavaux/issues/44)
- As an admin, I can send responses to user messages directly from the admin panel so that I can address their concerns quickly. [#45](https://github.com/jdohertydev/maison_lavaux/issues/45)
- As an admin, I can access a secure checkout process so that I feel confident that my payment details are safe. [#35](https://github.com/jdohertydev/maison_lavaux/issues/35)
- As an admin, I can process payments using Stripe so that I can handle transactions securely and reliably. [#36](https://github.com/jdohertydev/maison_lavaux/issues/36)

### First-Time Visitor Goals
- As a user, I can fill out a contact form on the website so that I can send inquiries or feedback to the company. [#42](https://github.com/jdohertydev/maison_lavaux/issues/42)
- As a user, I can see a detailed breakdown of my order total, including discounts and shipping, so that I understand the final price I am paying. [#39](https://github.com/jdohertydev/maison_lavaux/issues/39)
- As a user, I can receive an email confirmation after completing my order so that I know my transaction was successful. [#38](https://github.com/jdohertydev/maison_lavaux/issues/38)
- As a user, I can view a summary of the products in my cart so that I can confirm my order is correct before checkout. [#33](https://github.com/jdohertydev/maison_lavaux/issues/33)
- As a user, I can experience a clean and professional design so that I feel confident shopping on a high-quality website. [#16](https://github.com/jdohertydev/maison_lavaux/issues/16)
- As a user, I can access a clear and well-organised navigation menu so that I can find the information or products I need without frustration. [#17](https://github.com/jdohertydev/maison_lavaux/issues/17)
- As a user, I can access the website on my mobile device so that I can browse and shop seamlessly on the go. [#18](https://github.com/jdohertydev/maison_lavaux/issues/18)
- As a user, I can see visual or textual feedback when interacting with elements (e.g., buttons or forms) so that I know my actions have been registered. [#19](https://github.com/jdohertydev/maison_lavaux/issues/19)
- As a user with disabilities, I can use assistive technologies (e.g., screen readers) to navigate the site so that I can access the same features as any other user. [#20](https://github.com/jdohertydev/maison_lavaux/issues/20)
- As a user, I can experience minimal load times on every page so that I don't lose interest or abandon the site. [#21](https://github.com/jdohertydev/maison_lavaux/issues/21)

### Returning Visitor Goals
- As a returning user, I can securely save my payment details so that future purchases are faster and easier. [#40](https://github.com/jdohertydev/maison_lavaux/issues/40)
- As a returning user, I can manage my saved payment methods so that I can update or delete them as needed. [#40](https://github.com/jdohertydev/maison_lavaux/issues/40)
- As a returning user, I can apply discount codes or promotional offers to my order so that I can save money. [#39](https://github.com/jdohertydev/maison_lavaux/issues/39)
- As a returning user, I can review my previous purchases so that I can reorder or track my past orders. [#38](https://github.com/jdohertydev/maison_lavaux/issues/38)
- As a returning user, I can leave reviews for products I’ve purchased so that I can share feedback with other users. [#34](https://github.com/jdohertydev/maison_lavaux/issues/34)

## Design

The colour scheme for the website was carefully selected to reflect the brand's sophisticated and elegant identity. Black and white were chosen as the primary colours, as they convey a timeless and refined aesthetic while also being the simplest and most effective for accessibility. To complement this monochromatic foundation, a rose red was introduced as an accent colour. This striking yet classy choice adds a touch of warmth and distinction, making it perfect for highlighting key elements such as calls to action and interactive features. The result is a clean, accessible, and visually appealing design that aligns seamlessly with the brand's ethos.

### Colour Scheme

## Colour Palette

The following colours were chosen to create a sleek, sophisticated, and accessible design for the website:

| Colour        | Hex Code   | Usage                                      |
|---------------|------------|--------------------------------------------|
| **Black**     | `#000000`  | Backgrounds, buttons, overlays, text       |
| **White**     | `#FFFFFF`  | Text, light backgrounds, buttons, forms    |
| **Rose Red**  | `#E00034`  | Navigation bar, accents, attention-grabbing|
| **Grey**      | `#555555`  | General text                              |
| **Light Grey**| `#F1F1F1`  | Hover effects, subtle backgrounds          |
| **Muted Grey**| `#6C757D`  | Muted text, secondary content              |

To further enhance the design process, the palette was visualised using [Coolors](https://coolors.co/), allowing for a clear and cohesive representation of the chosen colours.

INSERT maison-lavaux-color-palette.png

The colour palette used for the website was tested using [WAVE Web Accessibility Evaluation Tool](https://wave.webaim.org/) and achieved a score of **0 contrast errors**, ensuring the design meets accessibility standards and provides excellent readability for users.

### Typography

For the website's typography, I selected the **Lato** font. Lato was chosen because it is clean, modern, and versatile, while also offering a sense of sophistication that aligns well with the brand's classy and elegant identity. Its wide variety of weights makes it suitable for both headings and body text, ensuring consistency across the site.

Lato was also used for the website logo, presented in uppercase to create a bold and striking impression that reinforces the brand's elegance and professionalism.

To ensure accessibility and functionality across all devices and browsers, I included a fallback font stack. If Lato is unavailable, the design defaults to a generic sans-serif font, maintaining readability and visual appeal.

### Wireframes

All the wireframes for the website were created using the Balsamic desktop application.

#### Desktop

<details>
  <summary>Hello</summary>
  
  My name is John
  
</details>

#### Mobile

### Database Entity Relationship Diagram

The Entity Relationship Diagram (ERD) below represents the models in the database and their relationships. The database consists of the following 11 models:

1. auth_user
2. analytics_salesdata
3. products_product
4. products_category
5. profiles_userprofile
6. products_review
7. account_emailaddress
8. account_emailconfirmation
9. checkout_order
10. checkout_orderlineitem
11. contact_contactmessage

### Relationships in the ERD

1. The profiles_userprofile model has a one-to-one relationship with the auth_user model, as each user can have only one profile.

2. The analytics_salesdata model has:
   - A one-to-many (Foreign Key) relationship with the products_product model, as each product can have many analytics records.
   - A one-to-many (Foreign Key) relationship with the auth_user model, as multiple analytics records can be associated with one user.

3. The products_product model has a one-to-many (Foreign Key) relationship with the products_category model, as each product belongs to one category, but a category can have many products.

4. The products_review model has:
   - A one-to-many (Foreign Key) relationship with the auth_user model, as one user can post many reviews.
   - A one-to-many (Foreign Key) relationship with the products_product model, as one product can have many reviews.

5. The account_emailaddress model has a one-to-one relationship with the auth_user model, as each user can have one primary email address.

6. The account_emailconfirmation model has a one-to-many (Foreign Key) relationship with the account_emailaddress model, as one email address can have multiple confirmations.

7. The checkout_order model has a one-to-many (Foreign Key) relationship with the profiles_userprofile model, as one user profile can have many orders.

8. The checkout_orderlineitem model has:
   - A one-to-many (Foreign Key) relationship with the checkout_order model, as one order can have many line items.
   - A one-to-many (Foreign Key) relationship with the products_product model, as many line items can represent one product.

9. The contact_contactmessage model has a one-to-many (Foreign Key) relationship with the auth_user model, as one user can send many contact messages.

Below is the Entity Relationship Diagram (ERD) for the Maison Lavaux project, which visualises the relationships between the various models in the database.

INSERT erd_maison_lavaux.png

### Agile Development

For the development of this project, I adopted **Agile development** methodologies to ensure a flexible and iterative approach. The process was structured around **epics**, **user stories**, **acceptance criteria**, and **tasks**, allowing for continuous feedback and improvement throughout the project. To prioritise features effectively, I employed **MoSCoW prioritisation**—which helped categorise requirements based on their importance. Additionally, **story points** were used to estimate the effort required for each task, allowing for better planning and tracking of progress in each sprint. This Agile approach ensured that the project remained adaptable and focused on delivering value to the users.

#### User Stories and Epics

During the project planning stage, I took the time to thoroughly consider and define the functional requirements for the website. I reflected deeply on the website's goals, its target audience, and the features that would best serve the users. Based on this reflection, I identified the core functionalities needed for the site.

After finalising this list of functional requirements, I converted them into user stories, represented as issues on GitHub. Any requirement that was too large to be considered a single user story was labelled as an **Epic**, and the related user stories were grouped under that epic. This approach allowed me to break down larger tasks into smaller, manageable pieces.

From the requirements, I created **6 epics** and additional user stories, totalling **45 user stories**. As the development progressed, some issues were identified as bugs, which were also tracked as user stories. For every epic that was created, all related user stories were referenced within that epic, ensuring clear tracking of tasks and progress.

#### MoSCoW Prioritization

Having created the user stories, I used **MoSCoW prioritisation** to ensure that the most important requirements were addressed first. MoSCoW is a useful technique for managing project scope and ensuring that critical tasks are prioritised, while also providing flexibility in the development process. Here's how I applied the MoSCoW method:

- **Must-Have**: Critical requirements that are essential for project success.
- **Should-Have**: Important requirements that significantly add value.
- **Could-Have**: Desirable features that provide additional benefits.
- **Won't-Have**: Features explicitly excluded from the project scope.

This method is beneficial as it allows for clear communication about what will be delivered in each iteration. It ensures that essential features are prioritised, while also managing expectations by clearly defining what will not be included. By using MoSCoW prioritisation, I was able to focus on delivering the highest value to users and stakeholders first, while still maintaining the flexibility to address lower-priority features later in the project.

#### Story Points

In this project, story points were used to estimate the relative complexity of each user story, enabling efficient time management and iteration planning. Each story was assigned a point value of 1, 2, 3, 5, 8, 13, or 21 based on the Fibonacci sequence, which provides a non-linear scale to account for increasing uncertainty with more complex tasks. By analysing the tasks and acceptance criteria for each story, I determined its difficulty relative to others, ensuring a realistic assessment of workload. This method facilitated the prediction of solo velocity for each iteration, aiding in the planning of future development cycles and prioritisation of features.

#### Iterations

#### Kanban Board

---

## Features

### Base Template File
For my project, the `base.html` template serves as the foundation for the overall structure and layout of the website. By centralising common elements such as the header, footer, and navigation in a single file, it ensures consistency across all pages and simplifies maintenance. This approach allows individual pages to focus on their unique content while inheriting the shared layout and functionality from the base template. From the `base.html` template, the following features are included on every page within the project:

#### Meta Tags
- Essential meta tags, including character encoding, viewport settings for responsiveness, and a default meta description that can be customised on individual pages.

#### CSS and JavaScript Includes
- Core CSS includes such as Bootstrap, Google Fonts, and custom styles from `base.css`.
- JavaScript libraries such as jQuery, Popper.js, Bootstrap JS, and Stripe for payment integration.
- Additional, page-specific CSS and JavaScript can be added via block tags (`corecss`, `extra_css`, `corejs`, `extra_js`).

#### Navigation Bar
- A fixed-top navbar with search functionality, user account options (login, profile, logout), and a shopping cart icon displaying the number of items in the cart.
- Dynamic greeting for logged-in users with their username or a "My Account" label for guests.

#### Header and Footer
- The header includes the website logo, main navigation, and a delivery banner for promotions.
- The footer contains links to information pages, social media profiles, and a newsletter subscription form.

#### Dynamic Content Blocks
- Custom content areas such as `meta`, `page_header`, and `content` are made flexible through the use of `{% block %}` tags, allowing pages to easily modify or extend these areas.

#### Toast Notifications
- Displays dynamic notifications (success, error, warning, info) based on messages in the request context.

#### Footer with Social Media and Newsletter Signup
- The footer features social media links (Facebook, Twitter, Instagram, LinkedIn) and a form to subscribe to newsletters.

#### Dynamic Year Display
- The current year is dynamically displayed in the footer using JavaScript, ensuring the copyright information remains up-to-date.

These features ensure a consistent user experience and allow for easy customisation of content across different pages, improving the maintainability and scalability of the project.

### Home Page

The homepage of Maison Lavaux is thoughtfully designed to provide an engaging and seamless user experience while showcasing our luxurious perfume collection. Below are the standout features:

#### **Dynamic Hero Section**
- A captivating hero banner featuring a high-resolution image, a dynamic overlay message, and a compelling call-to-action button directing users to browse the product catalog.
- The overlay includes slogan that changes every 5 seconds using JS (*"Discover Your Signature Scent", "Find the Perfect Fragrance for Any Occasion", "Unleash Your True Essence"*) to inspire visitors and enhance brand identity.


#### **Curated Product Sections**

The homepage offers multiple product categories, each tailored to meet diverse customer preferences:

- **New In**: Showcases the latest products added in the past 30 days, keeping the catalog fresh and exciting.

  ```python
  # New In Section (last 30 days)
    new_in_products = Product.objects.filter(
        created_at__gte=thirty_days_ago, is_active=True
    ).order_by('-created_at')[:4]
  ```

- **For Him and For Her**: Gender-specific product recommendations for a more personalized shopping experience.

  ```python
  # For Him Section (products for men)
  for_him_products = Product.objects.filter(
      gender='M', is_active=True
  ).order_by('-created_at')[:4]

  # For Her Section (products for women)
  for_her_products = Product.objects.filter(
      gender='W', is_active=True
  ).order_by('-created_at')[:4]
  ```

- **Most Popular**: Highlights the best-selling products based on revenue generated, leveraging data-driven insights.

  ```python
  # Most Popular Section (top 4 products by revenue)
  most_popular_products = Product.objects.annotate(
      total_revenue=Sum('sales_data__revenue_generated')
  ).order_by('-total_revenue')[:4]
  ```

- **Highest Rated**: Features top-rated products as reviewed by customers, ensuring quality recommendations.

  ```python
  # Highest Rated Section (top 4 highest rated products)
  highest_rated_products = Product.objects.filter(
      rating__isnull=False, is_active=True
  ).order_by('-rating')[:4]
  ```

- **Pot Luck**: A surprise selection of four random active products, encouraging discovery and delight.

  ```python
  # Pot Luck Section (random 4 active products)
  all_active_products = Product.objects.filter(is_active=True)
  random_products = random.sample(
      list(all_active_products), 4
  ) if all_active_products else []
  ```

#### **Interactive Product Cards**
- Each product card is designed with user engagement in mind, displaying:
  - High-quality product images with fallback placeholders.
  - Product names, categories, dynamic pricing (including original and discounted prices), and star ratings.
  - Interactive tags and links for easy navigation to related categories.

#### **Responsive and Accessible Design**
- Fully responsive layout ensuring a smooth browsing experience across desktop, tablet, and mobile devices.
- Alt text for images and semantic HTML elements to enhance accessibility for screen readers.

#### **Back-to-Top Button**
- A persistent "Back to Top" button allows users to navigate long pages effortlessly, improving overall usability.

#### **Search Engine Optimization (SEO)**
- Includes a descriptive meta tag: 
   *"Welcome to Maison Lavaux, your destination for handcrafted perfumes made in Paris. Explore our exclusive collection for men and women, featuring new arrivals, top-rated scents, and unique fragrances for every occasion."*
- This improves search visibility and effectively communicates the brand’s unique selling points.

By integrating these features, the homepage sets the tone for an exceptional online shopping experience while reinforcing the Maison Lavaux brand identity.

### Products Page

The products page on this site displays a dynamic catalogue of items available for purchase, allowing users to browse through a range of products, filter them by category, and sort them based on various criteria such as price, rating, or name. 

Each product card on the products page displays the following details:

- Product Image: A clear, high-quality image representing the product.
- Product Name: The name of the product, which links to its individual detail page.
- Price: The regular price of the product, with any applicable discounts displayed alongside.
- Discounted Price: If a product is on sale, the discounted price is displayed prominently.
- Product Rating: The product's average rating, shown as stars (if available).
- Category: The product’s category, with a link to view more products from the same category.

This ensures that users have a comprehensive view of each product at a glance, making it easier to decide on their purchases.

#### Dynamic Price Calculation

The dynamic price calculation feature ensures that users always see the most relevant pricing on the site. By prioritizing discounted prices when available, this functionality provides clarity and transparency, improving the overall shopping experience. It integrates seamlessly with sorting and filtering systems, enabling accurate and user-friendly price displays. 

- Ensures the most relevant price is displayed by prioritizing `discount_price` over the regular `price`.
- Utilizes Django's `annotate` method to create an `effective_price` field dynamically.
- Checks if a `discount_price` exists:
- If available, `effective_price` uses the `discount_price`.
- Otherwise, it defaults to the regular `price`.
- Fully integrated into product querysets, enabling:
- Dynamic sorting by `effective_price` (ascending or descending).
- Filtering and display of accurate prices across the site.
- Simplifies backend operations while ensuring consistent and accurate pricing for users.

#### Seamless Product Display with Inactive Item Exclusion

A key feature of this page is that products marked as inactive (`is_active = models.BooleanField(default=True)`) are automatically excluded from the display. This ensures that only available products are shown to the user, enhancing the shopping experience by preventing frustration  items. The page provides an intuitive and responsive layout with sorting options and real-time updates, ensuring a smooth and engaging shopping experience.


#### Pagination for Product Pages

A key feature missing from the walkthrough project *Boutique Ado* was pagination for the product pages, which I identified as an area for improvement. To enhance the user experience and improve site performance, I implemented pagination on the product pages. This feature divides the product listings into multiple pages, making it easier for users to browse large numbers of items without long load times. Each page displays a manageable number of products, and users can navigate through the available pages using the pagination controls. This functionality not only helps in presenting a more organised and responsive layout but also reduces server load by limiting the amount of data fetched at once. The pagination system is designed to be intuitive and user-friendly, providing clear navigation options for seamless browsing across various product categories.

### Product Details Page

#### Dynamic Product Information
- Displays detailed product information, including:
  - Name
  - Price (supports both original and discounted prices)
  - Category
  - Description
  - Size
  - Stock status
- Automatically adjusts for discounted products by showing both the original and discounted prices.

#### Image Handling
- Displays the product image if available.
- Provides a fallback "no image available" placeholder for missing images.
- Allows users to view the full-size image by clicking on it.
- Uses `alt` attributes to provide descriptive text for images, improving accessibility for screen readers and enhancing the user experience for visually impaired users.

#### Stock Management
- Provides dynamic stock status updates:
  - In Stock message for ample availability.
  - Hurry! warning is triggered when the stock quantity is greater than 0 but less than or equal to 5.
  - Out of Stock alert is triggered when the stock quantity is 0, with the "Add to Bag" button disabled for unavailable items.

#### Add to Bag Functionality
- Users can select the desired quantity using:
  - Increment and decrement buttons.
  - Direct input (supports quantities between 1 and 99).
- Ensures a smooth shopping experience by redirecting users back to the product page after adding to the bag.

#### Category Navigation
- Includes a link to related products by category, making it easy for users to explore similar items.

#### Superuser Capabilities
- Superusers have access to additional controls, such as:
  - Edit button to update product details.
  - Delete button with a modal confirmation to prevent accidental actions. This feature addresses a limitation in the Boutique Ado project, which lacked a confirmation step for deletions.

#### Mobile-Responsive Design
- Fully responsive layout optimized for various screen sizes, ensuring a seamless experience on mobile, tablet, and desktop devices.

#### JavaScript Integration
- Uses custom JavaScript for interactive features, such as:
  - Quantity adjustment buttons for selecting product quantities.

#### Meta Tags for SEO
- Includes dynamic meta descriptions for each product, enhancing search engine optimization and discoverability.

#### Accessible Navigation
- Features a "Keep Shopping" button that redirects users back to the main product catalog, allowing for easy navigation.

#### Product Review

The product review functionality is an integral part of the application, enabling users to provide feedback on products, rate their quality, and share their experiences with other potential buyers. Below is an explanation of how the feature works and why it is a significant improvement over the Boutique Ado project.

##### How the Product Review Feature Works

1. Dynamic Rating Update
   - The product's average rating dynamically updates whenever a new review is added or edited. This ensures that the displayed rating always reflects the latest user feedback.

2. Adding a Review
   - Authenticated users can submit a review for a product by filling in a form that includes a star rating and a comment.
   - The system checks if the user has already reviewed the product. If a review exists, they are notified that only one review per user is allowed.

3. Editing a Review
   - Users can edit their existing reviews. The form pre-fills with the user's current review details, allowing for easy updates, and any changes are saved back to the database.

4. Deleting a Review
   - Users can delete their reviews if they no longer wish to share their feedback. The review is permanently removed from the database upon confirmation.

5. Authentication Requirement
   - Only logged-in users can add, edit, or delete reviews. Unauthenticated users are prompted to log in, with their current page preserved as the redirect URL for a seamless experience.

6. Visibility on Product Pages
   - All reviews for a product are displayed on its detail page, showing:
     - Star rating
     - Review text
     - Date of posting
     - Reviewer's username

7. Review Management by Superusers
   - While reviews are primarily user-driven, superusers retain full administrative control over product-related data, ensuring data integrity and quality.

##### Why This Feature is Useful

1. Encourages Customer Engagement
   - The review feature provides a platform for users to share their opinions, fostering a sense of community and encouraging trust among customers.

2. Improves Product Transparency
   - With dynamic ratings and visible reviews, customers can make informed purchasing decisions based on real feedback from others.

3. Prevents Spam or Redundant Reviews
   - By restricting one review per user per product, the system avoids clutter and ensures that feedback remains meaningful and relevant.

4. Facilitates Easy Review Management
   - The ability to edit and delete reviews gives users full control over their feedback, reducing frustration and enhancing user satisfaction.

The Boutique Ado project did not include a review system, which limited customer engagement and product transparency. Without reviews or dynamic ratings, users were unable to provide feedback or view others' opinions. The addition of the product review feature in this project addresses these shortcomings, creating a more interactive and user-friendly shopping experience.

### Shopping Bag (Basket) Features

#### Backend Features

1. Add to Bag Functionality
   - Users can add products to their shopping bag, with options to select quantity and size (if applicable).
   - Stock availability is validated to ensure users cannot add more than the available quantity.

2. Adjust Bag Functionality
   - Allows users to update the quantity of items in the bag.
   - Validates stock availability during adjustments to prevent exceeding the available stock.
   - Dynamically updates the bag contents and session data.

3. Remove from Bag Functionality
   - Provides the ability to remove items from the shopping bag.
   - Handles both size-specific items and general products.
   - Returns appropriate responses (`200` or `500`) for success or failure.

4. Session-Based Bag Storage
   - Stores the shopping bag in the user's session, ensuring persistence across pages.
   - Handles size-specific quantities within the session data structure.

5. Error Handling
   - Displays error messages if users attempt to add or adjust quantities exceeding the available stock.
   - Uses the `messages` framework for clear feedback on user actions (e.g., updates, removals, or errors).

#### Frontend Features

1. Responsive Design
   - Fully responsive layout optimized for both mobile and desktop users.
   - Mobile view displays individual product details and totals, while the desktop view uses a table format for better readability.

2. Product Details
   - Displays product images, names, sizes (if applicable), prices, quantities, and subtotals in an organized manner.
   - Subtotals and total costs are dynamically calculated and displayed.

3. Interactive Quantity Adjustment
   - Users can increment or decrement product quantities directly in the bag.
   - Real-time validation and updates ensure accurate totals.

4. Dynamic Updates with JavaScript
   - Includes AJAX-powered functionality for removing items, avoiding a full page reload.
   - Ensures a smooth user experience when updating or removing items.

5. Empty Bag Handling
   - If the shopping bag is empty, a message is displayed to the user.
   - Includes a "Keep Shopping" button to redirect users back to the product catalog.

6. Checkout Integration
   - Clearly displays bag totals and provides checkout buttons for easy navigation to the checkout process.

7. Reusable Templates
   - Modular templates for product details, totals, and checkout buttons allow for consistent styling and easier maintenance.

8. User Feedback
   - Success and error messages inform users of updates, stock limitations, and removals, improving the overall user experience.

9. Back to Top Button
   - A floating "Back to Top" button improves navigation, especially for mobile users with long bag content.

### Checkout Page / Checkout Success 

#### Backend Features

1. Checkout form validation
   - Validates all form fields, including full name, email, address, and payment details.
   - Ensures data is correctly formatted and required fields are filled.

2. Session-based bag integration
   - Retrieves bag contents from the session to process orders seamlessly.
   - Validates that the bag is not empty before proceeding with the checkout.

3. Stripe payment integration
   - Uses Stripe's PaymentIntent to securely process payments.
   - Creates a PaymentIntent during checkout and uses client and server-side validation to ensure successful transactions.
   - Handles payment errors with clear feedback for the user.

4. Order and line item management
   - Creates an order model to store all relevant customer, product, and payment details.
   - Automatically generates unique order numbers using UUID.
   - Saves each item in the bag as an OrderLineItem linked to the parent order.

5. Stock management
   - Deducts product stock when an order is successfully processed.
   - Prevents orders from being placed if product stock is insufficient.

6. Stripe webhook handling
   - Listens for payment success or failure events from Stripe.
   - Processes orders via webhook events to ensure reliability, even if the user disconnects after payment.

7. User profile integration
   - Authenticated users can save delivery information to their profile for faster future checkouts.
   - Updates user profile information if "Save Info" is selected during checkout.

8. Error handling
   - Displays clear error messages for issues such as:
     - Invalid payment details.
     - Missing required fields.
     - Product availability issues.
   - Uses Django's messages framework for real-time user feedback.

#### Frontend Features

1. Responsive design
   - Checkout page is fully responsive, ensuring usability across all devices.

2. Order summary display
   - Provides a detailed summary of the user's bag contents, including:
     - Product name, size, and quantity.
     - Subtotals, delivery cost, and grand total.

3. Dynamic payment form
   - Implements Stripe's Card Element for secure and user-friendly card input.
   - Displays real-time validation errors within the payment form.

4. Loading overlay
   - A loading animation appears while processing payments, enhancing the user experience.

5. Confirmation page
   - Displays a detailed confirmation page after successful checkout, including:
     - Order number and date.
     - Billing and delivery details.
     - List of ordered items with quantities and subtotals.
   - Provides clear navigation options to return to the product catalog or the user's profile.

6. Save information option
   - Allows logged-in users to save delivery details to their profile for future use.
   - Offers non-authenticated users the option to sign up or log in to enable this feature.

7. Reusable templates
   - Modular templates for the form, order summary, and confirmation page ensure consistency and easy maintenance.

8. Interactive adjustments
   - Users can navigate back to the bag page to adjust quantities or remove items before finalizing the order.

#### Order Confirmation Email

- The checkout system includes an automatic confirmation email feature that provides customers with detailed information about their order.
- Upon successful payment, the system generates and sends a personalized email to the customer using the email address provided during checkout.
- The email includes key order details such as:
  - Order number
  - Order date
  - Total cost
  - Delivery address
  - Contact information
- The email reassures the customer that their order has been successfully processed.
- It offers clear instructions for reaching out with any questions or concerns.
- By delivering a professional and personalized confirmation email, the feature:
  - Enhances customer satisfaction
  - Builds trust in the brand
  - Provides an immediate record of the transaction

#### Using Django Humanize for Displaying Amounts

The checkout system leverages Django's `humanize` library to improve the presentation of monetary values throughout the application. Features such as the order total, delivery cost, and grand total are formatted using `humanize` filters like `floatformat` and `intcomma`. These filters ensure that amounts are displayed with consistent formatting, making them more readable and user-friendly.

##### Benefits

1. Improved readability
   - The `intcomma` filter automatically adds commas to large numbers (e.g., `10000.00` becomes `10,000.00`), improving clarity, especially for international customers.

2. Precision and consistency
   - The `floatformat` filter ensures that all amounts are consistently displayed with two decimal places (e.g., `15` is formatted as `15.00`), creating a polished and professional appearance.

3. Enhanced user experience
   - Clear and consistent formatting reduces confusion and provides a smoother checkout experience by presenting financial information in an accessible format.

The Boutique Ado project lacked the use of the `humanize` library, which resulted in inconsistent or raw numeric formatting for monetary values. This inconsistency could lead to a less professional appearance and potential confusion for users. By incorporating `humanize`, this project represents a clear improvement, ensuring that all amounts are displayed in a polished and user-friendly format that aligns with customer expectations for e-commerce platforms.

### Profile Page

The profile app provides users with a personalized area to manage their default delivery information, view their order history, and update personal details like name and email. This app ensures a streamlined and user-friendly experience for managing account information and past transactions.

#### Backend Features

1. User Profile Model
   - Stores default delivery details such as:
     - Phone number
     - Address lines
     - Town or city
     - County
     - Postcode
     - Country
   - Links each profile to a User instance using a one-to-one relationship.
   - Automatically creates or updates the profile when a user is created using Django signals.

2. Order History Retrieval
   - Associates user profiles with their past orders, enabling users to view a detailed order history.
   - Provides detailed information about each order, including order number, date, items, and total cost.

3. Forms for User and Profile Updates
   - UserProfileForm for updating default delivery information with:
     - Custom placeholders and classes for consistency.
     - Focus on user-friendly design with a clean interface.
   - UserUpdateForm for updating personal details such as first name, last name, and email.

4. View Functions
   - profile: Displays the user's profile page, allowing updates to delivery information and personal details.
   - order_history: Provides detailed information about past orders, with a message confirming that the order has already been processed.

#### Frontend Features

1. Profile Page
   - Displays the user's personal details and default delivery information in a responsive, user-friendly layout.
   - Includes separate sections for:
     - Personal Information
     - Default Delivery Information
   - Features a single form for updating all information, submitted via a POST request.

2. Order History Table
   - Displays a list of the user's past orders in a table format with columns for:
     - Order number (clickable link for more details)
     - Order date (displayed using natural language)
     - Order items (including product name, size, and quantity)
     - Grand total
   - Responsive design ensures readability on all device sizes.

3. Order History Details
   - Provides a detailed breakdown of individual orders, including:
     - List of items ordered
     - Delivery address
     - Total costs, including delivery charges
     - Timestamp of the order date
   - Reuses the checkout success page template for consistency.

4. Form Design
   - All forms use the Crispy Forms library for a consistent and responsive design.
   - Custom placeholders and autofocus improve usability and guide users during input.

5. Error and Success Messaging
   - Displays clear feedback when forms are submitted:
     - Success messages confirm updates were saved successfully.
     - Error messages highlight validation issues or missing required fields.

#### Key Features

- Automatic profile creation ensures every user has a profile upon registration.
- Centralized profile management combines personal details and delivery information in one place.
- Detailed order history provides users with a complete overview of their transactions.
- Reusable design leverages modular templates for consistent styling across the app.
- Responsive and accessible design ensures usability on mobile, tablet, and desktop devices.
- Improved user experience through user-friendly form design and intuitive navigation.

The profile app enhances the overall user experience by providing a centralized, efficient, and accessible way to manage personal information and review past transactions. 

### Add / Edit / Products Page

This project includes product management functionality that enables authorized users to efficiently add, edit, and delete products directly through the frontend interface.

#### Add Product Functionality

The application includes a dedicated form and view for adding products:

- GET Request: The `add_product` view renders the `add_product.html` template with an empty `ProductForm` for entering product details.
- POST Request: When the form is submitted, the data is validated. If valid, the new product is saved to the database, and the user is redirected to the product detail page. If invalid, error messages guide the user to correct the issues.

The `add_product.html` template includes CSRF protection and uses Django's templating language for consistent rendering and security.

#### Edit Product Functionality

Editing existing products is handled by a similar process:

- GET Request: The `edit_product` view retrieves the product by its ID and pre-populates the `ProductForm` with the current data. The form is displayed in the `edit_product.html` template for user modifications.
- POST Request: On submission, the data is validated. If valid, the updates are saved, and the user is redirected to the product detail page. If invalid, error messages are displayed to assist the user.

The `edit_product.html` template is designed to mirror the add product page while displaying existing data for convenience.

#### Delete Product Functionality

The application provides a secure method for deleting products through the `delete_product` view:

- Access Control: Only superusers can perform deletions, ensuring this action is limited to authorized personnel.
- Process: The specified product is retrieved by its ID, deleted from the database, and the user is redirected to the product list with a success message.

This deletion feature is linked from the product detail and list pages for easy access.

#### Access Control

All product management views include safeguards to ensure only authorized users have access:

- The `@login_required` decorator restricts access to authenticated users.
- Additional checks confirm that only superusers can add, edit, or delete products.

These measures ensure secure and reliable product management, protecting the integrity of the catalog.

### Admin Panel

The Django admin panel provides a centralized interface for managing all aspects of the application efficiently. It highlights the key apps created for this project, including:

- Accounts: Manage user accounts and email addresses.
- Analytics: View and manage sales data for performance tracking.
- Authentication and Authorization: Control user access with groups and permissions.
- Checkout: Oversee orders and their details.
- Contact: Manage messages sent through the contact form.
- Products: Add, edit, and manage categories, products, and reviews.
- Sites: Configure and manage site-related settings.

#### Purpose and Benefits

The admin panel is an essential tool for streamlining application management. It allows administrators to handle backend operations such as user management, order processing, and content updates without requiring direct interaction with the database. This approach reduces errors, increases efficiency, and provides a user-friendly environment for maintaining the application.

### Analytics App

The Analytics app is a flagship feature of this project and provides powerful tools for tracking and analyzing product performance. It integrates seamlessly with the rest of the application and is designed to give administrators valuable insights into customer behavior and product trends.

#### Key Features

- Tracks essential metrics for each product, including:
  - Views: The number of times a product is viewed.
  - Purchases: The total purchases of a product.
  - Added to Cart: How often a product is added to the cart.
  - Revenue Generated: The total revenue a product has earned.
- Automatically creates and maintains sales data for all active products, ensuring that no data is missing or overlooked.
- Includes custom filters in the admin panel:
  - Revenue Range: Allows filtering products by low, medium, or high revenue brackets.
  - Updated At: Enables filtering by the most recently updated entries.
- Highlights top-performing or trending products with labels such as "Top Seller" or "Trending" for easy identification in the admin panel.
- Displays product ratings directly in the admin panel, sortable for convenience.
- Includes a search functionality that allows administrators to quickly locate specific products by name.

#### Why This is Useful

The Analytics app provides a centralized dashboard for monitoring product performance. By tracking metrics like views, purchases, and revenue, administrators can:

- Identify top-performing products and make data-driven decisions to promote them further.
- Spot underperforming items and strategize improvements to boost their visibility and sales.
- Gain insights into customer behavior, such as popular products and frequently added items, to optimize marketing and inventory management.
- Evaluate revenue trends to ensure business goals are being met.

#### Improvements Over Basic Applications

Unlike standard Django applications, this project introduces custom filters and sorting options that allow for a more tailored and efficient analysis. The automated creation of missing sales data ensures comprehensive tracking without manual intervention, setting it apart as a professional-grade feature.

The Analytics app is a testament to the project's focus on combining functionality with insightful data visualization, making it an invaluable tool for administrators and stakeholders.

### Toast Messaging

Toast messages have been implemented throughout the project to provide feedback to users on various actions and processes. These messages appear dynamically to inform users of the success, error, warning, or informational status of their interactions. For example, toast messages are used when products are successfully added to the shopping bag, when users log in or sign up, and to notify them of any errors or confirmations in the checkout process.

The toast notifications are included in the project through the `includes/toasts` folder, using the `toast_error.html`, `toast_success.html`, `toast_warning.html`, and `toast_info.html` templates. These messages are displayed in a user-friendly format, improving the overall user experience by offering instant feedback without interrupting their flow on the page.

Each toast message is contextually relevant, ensuring that users understand the result of their actions, such as whether an operation was successful or if there was an error that needs addressing. The notifications are designed to be responsive, providing a consistent experience across all devices.

### Privacy Policy

The Privacy Policy page provides users with clear information about how their personal data is collected, used, and protected in compliance with GDPR. It outlines data usage purposes, user rights, and contact information for privacy inquiries, ensuring transparency and trust. This static page demonstrates the project's commitment to legal compliance and ethical data practices.

### About Us Page

The About Us page shares the story of Maison Lavaux and its founder, Antoine Lambert. It highlights his journey from Lavaux's vineyards to becoming a master perfumer in Paris, overcoming challenges and creating a brand known for its craftsmanship and sophistication.

#### Key Features

- Provides a brief biography of Antoine Lambert and his passion for perfumery.
- Tells the story of the brand's origins and dedication to creating meaningful scents.
- Includes visually engaging elements such as a profile image of Antoine and a call-to-action button linking to the product catalog.

#### Purpose

The About Us page connects customers with the brand's story, emphasizing its commitment to quality and artistry. It builds trust and inspires customers to explore the Maison Lavaux collection.

### Contact Page

The Contact Page allows users to reach out to Maison Lavaux for inquiries, support, or feedback, integrating seamlessly with the Contact app. This app includes both frontend and backend functionalities to manage user messages efficiently. By enabling clear communication, the Contact Page enhances customer support and ensures messages are tracked and addressed promptly, contributing to a seamless user experience.

#### Key Features

- User-friendly form that allows users to submit their name, email, subject, and message.
- Pre-filled fields for registered users to simplify the process.
- Database integration to store submitted messages for tracking and follow-up.
- Admin notification via email for each new message to ensure timely responses.
- Acknowledgment for users with a confirmation message and estimated response time.

#### Admin Features

- Admin panel management for viewing, replying to, and resolving contact messages.
- Filters for resolved and replied statuses to streamline message handling.
- Search functionality to locate messages by name, email, subject, or content.

### Custom Error Pages

To enhance the user experience, custom error pages were implemented for common HTTP error statuses: 400 (Bad Request), 403 (Forbidden), 404 (Not Found), and 500 (Internal Server Error). These pages go beyond the standard error messages, incorporating a sense of playfulness to make the experience less frustrating for users. The goal of these custom error pages is to transform potentially negative interactions into opportunities for engagement, ensuring users feel valued even when something goes wrong. This approach contributes to a more positive perception of the brand and a seamless user experience.

#### Key Features

- Custom designs maintain the branding of Maison Lavaux, ensuring a consistent visual identity across the site.
- User-friendly messaging provides clear explanations of errors and offers guidance to help users navigate back to the site or resolve issues.
- Playful and engaging language reduces frustration and creates a more enjoyable interaction during error scenarios.

#### Email Verification

#### Email Verification

The project implements an email verification system for new user registrations, requiring users to confirm their email addresses before fully activating their accounts. The configuration ensures that email verification is mandatory, and users must enter their email twice during signup to reduce errors.

#### Benefits

- Enhanced security: Verifying email addresses helps prevent fraudulent account creation and ensures that users can be contacted through valid, accessible email addresses.
- Improved communication: By confirming valid emails, the system ensures users can receive important updates, order confirmations, and promotional materials, enhancing customer engagement.
- Trust and credibility: Mandatory email verification adds professionalism and trustworthiness to the site, reassuring customers that their data is handled securely.
- Reduced spam and abuse: This feature mitigates the risk of spam accounts, safeguarding the site from malicious activity that could harm its reputation.
- Error reduction: Requiring users to enter their email twice minimizes typographical errors, ensuring that communications reach the correct recipients.

### Back to Top Button

A "Back to Top" button is available on the Home and Products pages to enhance user navigation and overall experience. This feature allows users to quickly return to the top of the page, improving accessibility and usability, especially on pages with extensive content. It demonstrates attention to detail and a commitment to creating a seamless, user-friendly interaction, contributing to a more intuitive and enjoyable browsing experience.

#### Implementation Details

- Smooth scrolling effect: The button uses a JavaScript implementation to create a seamless scrolling experience. When clicked, the page scrolls smoothly to the top rather than jumping abruptly, providing a more polished interaction.
- Event listener: A JavaScript script initializes the functionality by adding an event listener to the "Back to Top" button (`.btt-link`). This ensures that clicking the button triggers the smooth scroll behavior.
- DOM content loaded check: The script waits for the DOM content to be fully loaded before adding the event listener, ensuring the button is available and ready for interaction.
- User-friendly design: The button is unobtrusive and appears only when relevant, allowing users to focus on browsing without distractions.

#### Benefits for User Experience

- Efficient navigation: Users can return to the top of the page without manually scrolling, saving time and reducing frustration.
- Accessibility: Improves the site's accessibility, particularly for users browsing on mobile devices or with assistive technologies.
- Professional aesthetic: The smooth scrolling effect adds a modern touch to the site, aligning with contemporary web design standards.

### Basket Badge

To enhance the user experience, the basket icon includes a dynamic badge that shows the number of items in the basket. This feature provides several key benefits:

- Visual clarity: Users receive a clear and immediate indication of how many items they have added to their basket.
- Improved usability: Eliminates the need to navigate away from the current page to check the basket contents.
- E-commerce best practices: Aligns with standard practices in online shopping platforms, ensuring familiarity for users.
- Enhanced shopping experience: Helps users keep track of their selections, making the overall experience more intuitive and user-friendly.

This small but impactful detail highlights the focus on delivering a polished and professional interface tailored to user needs.

### Form Validation

Form validation in the project ensures that user inputs are accurate, complete, and secure. This is implemented across various features to enhance functionality and user experience. Key aspects of form validation include:

- Profile Forms:
  - Delivery and personal information forms in the Profile app use `forms.ModelForm` for automatic validation of required fields, data types, and email formats.
  - Additional validation logic is implemented to ensure completeness of user details.

- Checkout Forms:
  - During checkout, forms validate user-provided order details, including address and contact information. This ensures accurate data is submitted before order processing.
  - Validation checks for required fields such as email and ensures postal codes follow proper formatting.

- Contact Forms:
  - The Contact page form uses `forms.Form` to validate fields such as name, email, and message content.
  - Clear error messages are displayed to guide users in correcting invalid inputs.

- Product Management Forms:
  - Forms for adding and editing products include custom validation logic to ensure that the discount price is less than the original price.

- Django's Built-in Features:
  - Utilizes Django's `forms` library to enforce field requirements, validate email addresses, and provide error feedback for invalid inputs.
  - Includes client-side validation where possible for a smoother user experience.

### Future Implementations

To enhance the platform's functionality and user experience, the following features are planned for future development:

- **Order Fulfillment Notifications**  
  Automatically notify customers via email or SMS when their orders are fulfilled, improving communication and customer satisfaction.

- **Return and Refund Management**  
  Introduce a streamlined process for handling product returns and issuing refunds, including admin tools for tracking return requests and automating refund workflows.

- **Advanced Stock Management**  
  Implement features to handle low stock alerts, automated stock replenishment notifications, and better tracking of inventory levels for concurrent orders.

- **Wishlist Functionality**  
  Allow users to save items to a wishlist for future purchase, encouraging customer retention and repeat visits.

- **Order Tracking System**  
  Provide customers with real-time tracking of their orders, including shipment progress and expected delivery dates.

- **Multi-Currency Support**  
  Enable users to view product prices and complete purchases in their preferred currency, broadening the site's global appeal.

- **Loyalty Program Integration**  
  Develop a points-based system to reward repeat customers, incentivizing continued engagement with the platform.

- **Enhanced Review System**  
  Allow users to upload images with their reviews, offering more detailed feedback and enriching the shopping experience for future buyers.

- **Dynamic Pricing for Promotions**  
  Automate temporary price reductions for flash sales or holiday promotions, with a countdown timer displayed on product pages.

These planned implementations aim to create a more robust, engaging, and efficient platform for both customers and administrators.

### Accessibility and Good Practice

Accessibility is a core consideration throughout the project, ensuring the website is inclusive and user-friendly for all audiences, including those with disabilities. This focus on accessibility also enhances usability and aligns with best practices in modern web development.

- **Semantic Structure**: The site uses semantic HTML elements such as `<header>`, `<nav>`, `<main>`, and `<footer>` to create a logical structure. This improves navigation for assistive technologies like screen readers.
- **Accessible Forms**: All forms are designed with clearly labeled fields, accessible input types (e.g., `email` and `tel`), and visual indicators for required fields. These features ensure that users can easily interact with forms, regardless of ability.
- **Contrast and Readability**: Text and background color combinations are chosen to meet accessibility contrast standards, making content readable for visually impaired users.
- **Responsive Design**: The website is fully responsive, ensuring that it functions seamlessly across devices, from desktops to mobile phones. This adaptability enhances accessibility for users relying on various technologies.
- **Alt Text for Images**: All images include meaningful `alt` attributes to describe their content. This ensures users with visual impairments can understand the context and purpose of visual elements.
- **Keyboard Navigation**: Features such as the "Back to Top" button are fully keyboard accessible, allowing users to navigate efficiently without relying on a mouse.
- **Custom Error Pages**: Custom 400, 403, 404, and 500 error pages provide clear instructions and maintain accessibility standards, ensuring users can recover from errors with ease.

By implementing these practices, the project demonstrates a commitment to creating an inclusive and enjoyable user experience for all.

## E-Commerce Business Model

This application incorporates several key strategies to ensure a sustainable and successful e-commerce business. Below are the primary components that underline the model:

### Search Engine Optimization (SEO)

Effective SEO techniques have been integrated to improve the visibility and reach of the website. Key features include:

- Meta tags: Meta descriptions and keywords are dynamically added within Django templates to improve search engine rankings, using carefully researched long and short-form keywords identified through brainstorming, Google tools, and keyword analysis.
- Sitemap: A sitemap file is provided, allowing search engines to efficiently crawl and index the site's structure.
- Robots.txt: A robots.txt file has been included to guide search engines on which parts of the site to crawl and index, optimizing the crawl budget.

Other optimizations include:

- Alt text for images: All product images include descriptive alt text, making the site more accessible and improving image search rankings.
- Mobile responsiveness: The site's design is fully responsive, catering to a growing audience of mobile users, which search engines favour.
- Optimized URLs: The application uses clean and descriptive URLs, which are user-friendly and beneficial for SEO.

### Social Media Marketing

To support the website, a Facebook Business Page has been created. This serves as an additional platform for brand visibility and user engagement.

- Why businesses use Facebook pages: Social media platforms, especially Facebook, allow businesses to connect directly with their audience, foster community, and share updates about products or promotions.
- Value to the company: A Facebook page increases the company’s reach, drives traffic to the website, and creates a space for user-generated content, such as reviews and testimonials, which can further boost credibility.

### Newsletter Marketing

The website features a newsletter signup option in the footer, enabling users to subscribe by sharing their email addresses. This approach offers several advantages:

- User retention: Regular newsletters keep the brand in the minds of customers, encouraging repeat visits and purchases.
- Targeted marketing: Collecting user data allows for more personalized and segmented marketing campaigns, increasing conversion rates.
- Announcements and promotions: Newsletters provide a direct channel for communicating new product launches, sales events, and exclusive discounts to loyal customers.

By combining these strategies, the e-commerce application creates a strong foundation for attracting, engaging, and retaining customers while maintaining scalability for future growth.


## Future Strategies to Support the E-Commerce Business Model

To further enhance the e-commerce business model and drive growth, the following strategies could be implemented in the future:

### Advanced SEO Techniques

- Structured Data Markup: Adding schema.org markup to product pages to improve how information appears in search results, including rich snippets for reviews, prices, and availability.
- Voice Search Optimization: Tailoring content to accommodate the growing trend of voice search, using natural language and question-based keywords.
- Faster Page Load Times: Optimizing images, implementing lazy loading, and using Content Delivery Networks (CDNs) to enhance page speed, which is critical for SEO and user experience.

### Expanded Social Media Marketing

- Multi-platform Presence: Establishing a presence on platforms like Instagram and Pinterest, which are highly visual and align well with the luxury perfume market.
- Influencer Partnerships: Collaborating with influencers to promote products, increase brand credibility, and reach niche audiences.
- Social Commerce: Integrating product catalogs directly into social media platforms for seamless shopping experiences.

### Email Marketing Enhancements

- Drip Campaigns: Creating automated email sequences to nurture leads, onboard new customers, and re-engage inactive users.
- Personalization: Using customer data to send tailored recommendations, offers, and content to improve engagement and conversions.
- Analytics Integration: Using email marketing analytics to measure the success of campaigns and refine strategies over time.

### Customer Loyalty Programs

- Reward Systems: Introducing a points-based loyalty program where customers earn points for purchases and redeem them for discounts or exclusive products.
- Referral Incentives: Encouraging existing customers to refer friends by offering both parties discounts or rewards.

### Mobile App Development

- Dedicated Mobile App: Building a mobile application to provide a more personalized and streamlined shopping experience, including push notifications for promotions and exclusive offers.
- Mobile Payments: Incorporating additional mobile payment options like Apple Pay and Google Pay for convenience and user satisfaction.

### Data-Driven Decision Making

- Analytics Dashboards: Implementing detailed analytics dashboards to track sales trends, customer behavior, and marketing effectiveness.
- Predictive Analytics: Using machine learning to predict customer preferences and optimize inventory management.

### Diversified Product Offerings

- Product Bundles: Offering curated product bundles to increase average order value and enhance customer satisfaction.
- Limited Edition Products: Introducing seasonal or limited edition items to create urgency and exclusivity.

### International Expansion

- Multi-language Support: Translating the site into additional languages to cater to a global audience.
- Cross-border Shipping: Offering competitive international shipping options to expand the customer base.

By adopting these strategies, the e-commerce business can maintain competitiveness, foster customer loyalty, and scale effectively for long-term success.

---

## Technologies Used

### Languages

- [CSS](https://developer.mozilla.org/en-US/docs/Web/CSS) - Used to style the website's HTML content.
- [HTML5](https://developer.mozilla.org/en-US/docs/Web/HTML) - Used to structure and create pages (templates) for the website, defining its content.
- [JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript) - Used to add dynamic behavior to the website.
- [Python](https://www.python.org/) - Used to implement server-side logic and interact with the database.

### Frameworks

- [Bootstrap5](https://getbootstrap.com/) - Used for front-end development, focusing on responsive design and layout.
- [Django](https://www.djangoproject.com/) - Used to implement the Model-View-Template (MVT) architectural pattern and handle backend functionality.

### Databases Used

- [ElephantSQL](https://www.elephantsql.com/) - PostgreSQL database service provider for deployment.
- [PostgreSQL](https://www.postgresql.org/) - Used as a local database during development.

### Libraries, Modules, and Packages

- [Boto3](https://boto3.amazonaws.com/v1/documentation/api/latest/index.html) - Used to interact with AWS services (S3 storage).
- [Django Storages](https://django-storages.readthedocs.io/) - Used to simplify static and media file storage management in conjunction with AWS S3.
- [django-crispy-forms](https://django-crispy-forms.readthedocs.io/) - Used for rendering Django forms with Bootstrap styles.
- [dj-database-url](https://pypi.org/project/dj-database-url/) - Used for parsing database connection URLs.
- [gunicorn](https://gunicorn.org/) - Used as a WSGI server for running the Django application in production.
- [Pillow](https://pillow.readthedocs.io/) - Used for handling image file uploads and processing.
- [psycopg2](https://pypi.org/project/psycopg2/) - Used as a PostgreSQL adapter for Django.
- [Stripe](https://stripe.com/) - Used for payment processing, offering a developer-friendly API and excellent testing tools.

### Version Control

- [Git](https://git-scm.com/) - Used for version control via the terminal.
- [GitHub](https://github.com/) - Used as the remote repository to store and manage the project.

### Programs and Tools

- [Balsamiq](https://balsamiq.com/) - Used to create wireframes for the project.
- [ChatGPT](https://openai.com/chatgpt) - Used to generate design images and to create the privacy policy for the website.
- [Coolors](https://coolors.co/) - Used to visualize and generate the color palette.
- [dbdiagram](https://dbdiagram.io/) - Used to create the Entity Relationship Diagram (ERD).
- [Font Awesome](https://fontawesome.com/) - Used to include icons for enhanced user experience.
- [GitPod](https://www.gitpod.io/) - Integrated Development Environment (IDE) used for writing and managing code.
- [Google Fonts](https://fonts.google.com/) - Used to research and import fonts for the website.
- [Google Lighthouse](https://developers.google.com/web/tools/lighthouse/) - Used to test the website’s performance, accessibility, and SEO.
- [TinyPNG](https://tinypng.com/) - Used to compress images for faster loading times.
- [W3C CSS Validator](https://jigsaw.w3.org/css-validator/) - Used to validate the CSS code.
- [W3C HTML Validator](https://validator.w3.org/) - Used to validate the HTML code.
- [CI Python Linter](https://github.com/code-institute-org/python-essentials/blob/master/linter/readme.md) - Used to validate Python code.

### Hosting and Deployment

- [AWS S3](https://aws.amazon.com/s3/) - Used for hosting static and media files.
- [Heroku](https://www.heroku.com/) - Used for deploying the project online and managing the production environment.

---

## Dependency Setup, Deployment and Local Deployment

### Create and Connect a Database

To ensure the deployed project on Heroku has access to a persistent database, a remote PostgreSQL database was created. Below are the steps taken to set up the database and connect it to the project.

---

#### Why Is a Remote Database Needed?

The local database used during development is only accessible within the IDE. A remote database is required to support the deployed Heroku application, enabling it to store and retrieve data seamlessly.

---

#### Steps to Create a PostgreSQL Database

1. **Access the PostgreSQL Service**:
   - Navigate to the [PostgreSQL from Code Institute](https://codeinstitute.net/) service page.

2. **Enter Your Email**:
   - Enter your Code Institute student email address in the provided input field.

3. **Submit the Request**:
   - Click the **Submit** button to initiate the database creation process.

4. **Wait for Confirmation**:
   - A loading screen will appear with animated cogs indicating progress.
   - Once completed, you’ll be directed to a success page.

5. **Check Your Email**:
   - Review the email sent to your student inbox. It contains the database connection details needed for integration.

---

#### Connecting the Database to the Project

1. **Update Heroku**:
   - Log in to [Heroku](https://heroku.com/) and open your app’s dashboard.
   - Add the database credentials from the email to your app’s **Config Vars**.

2. **Apply Migrations Locally**:
   - Temporarily connect your IDE workspace to the new database by adding the credentials to your **settings.py** file.
   - Run the following commands to apply migrations:
     ```bash
     python manage.py makemigrations
     python manage.py migrate
     ```

3. **Revert Local Configuration**:
   - After completing the migrations, revert your local database settings in **settings.py** to use the development database.

---

#### Final Integration

The PostgreSQL database is now connected to your Heroku app.

### Amazon Web Services (AWS) Setup for Static Files and Images

AWS was used to store images and static files for this project. Follow these steps to configure **S3** and **IAM** for seamless integration.

---

#### S3 Configuration

1. **Create an S3 Bucket**:
   - Sign in to [AWS](https://aws.amazon.com/).
   - Search for **S3** and click **Create bucket**.
   - Enter a **Bucket name**.
   - Select **ACLs enabled**.
   - Deselect **Block all public access**.
   - Click **Create bucket**.

2. **Enable Static Website Hosting**:
   - Open your bucket and go to the **Properties** tab.
   - Scroll to **Static website hosting** and click **Edit**.
   - Turn on **Static web hosting**.
   - Choose **Host a website**.
   - Specify `index.html` and `error.html` for the fields.
   - Save changes.

3. **Set Up Permissions**:
   - Go to the **Permissions** tab.
   - Scroll to **CORS configuration** and add the following:
     ```json
     [
         {
             "AllowedHeaders": ["Authorization"],
             "AllowedMethods": ["GET"],
             "AllowedOrigins": ["*"],
             "ExposeHeaders": []
         }
     ]
     ```
   - Copy the **ARN** from the **Properties** tab.
   - In the **Bucket policy** section, click **Edit** and use the following:
     - Open **Policy Generator** and configure:
       - **Type**: S3 Bucket Policy
       - **Effect**: Allow
       - **Principal**: `*`
       - **Service**: Amazon S3
       - **ARN**: Paste the previously copied ARN.
     - Click **Add Statement** and **Generate Policy**.
     - Copy the generated policy, paste it into the **Bucket Policy Editor**, and append `/*` to the ARN.
     - Save changes.

4. **Update Access Control List (ACL)**:
   - In the **Permissions** tab, go to **Access control list (ACL)** and click **Edit**.
   - Enable **List** access for **Everyone (public access)**.
   - Accept the warning and save.

---

#### IAM Configuration

1. **Create a User Group**:
   - Search for **IAM** in AWS and open the dashboard.
   - Go to **User Groups** and click **Create group**.
   - Enter a **Group name** and click **Create group**.

2. **Create and Attach a Permissions Policy**:
   - Open the **User Group** you just created.
   - Navigate to the **Permissions** tab and select **Create inline policy**.
   - Use the following steps to configure:
     - Select **Import managed policy**.
     - Search for **AmazonS3FullAccess** and click **Import**.
     - Switch to the **JSON** tab and paste this policy:
       ```json
       {
           "Version": "2012-10-17",
           "Statement": [
               {
                   "Effect": "Allow",
                   "Action": ["s3:*", "s3-object-lambda:*"],
                   "Resource": [
                       "arn:aws:s3:::bucket-name",
                       "arn:aws:s3:::bucket-name/*"
                   ]
               }
           ]
       }
       ```
       Replace `bucket-name` with your bucket’s actual name.
     - Click **Review Policy**, give it a **Name** and **Description**, and click **Create policy**.

3. **Attach Policy to the User Group**:
   - Go to the **User Group**’s **Permissions** tab.
   - Select **Attach policy**, search for the policy you just created, and click **Attach policy**.

---

#### Adding Users

1. **Create a New User**:
   - In the IAM dashboard, go to **Users** and click **Add users**.
   - Enter a **User name**.
   - Select **Programmatic Access** and click **Next**.

2. **Assign the User to a Group**:
   - Add the user to the group you created earlier.
   - Click **Next** and then **Create user**.

3. **Save Access Keys**:
   - Note down the **Access Key ID** and **Secret Access Key** or download the provided CSV file (this information will not be shown again).

---

#### Project Configuration

1. Add the following AWS credentials to your environment variables (e.g., in Heroku):
   - `AWS_ACCESS_KEY_ID`
   - `AWS_SECRET_ACCESS_KEY`

2. Update your project’s settings file with the appropriate AWS configurations:
   - Configure static and media file storage to use the S3 bucket.
   - Test the integration to ensure all static files and images are properly served.

---

By following these steps, your AWS S3 bucket and IAM settings will be configured to manage and serve static files and images efficiently.

### Payment System Setup

### Stripe Setup for Payment Processing

Stripe is integrated as the payment system for this website, offering a secure and seamless checkout experience. Follow the steps below to configure Stripe for your project:

---

#### Steps to Configure Stripe

1. **Log in to Stripe**:
   - Visit the [Stripe website](https://stripe.com/) and log in to your account.

2. **Access API Keys**:
   - Navigate to the **Developers** section in the Stripe dashboard.
   - Go to the **API Keys** tab.
   - Copy the **Public Key** and **Secret Key**.

3. **Set Up Webhooks**:
   - Go to the **Webhooks** tab under the **Developers** section.
   - Click **Add Endpoint**.
   - Enter the webhook endpoint URL using the address of your deployed website (e.g., `https://yourdomain.com/stripe/webhook/`).
   - Select **All Events** to ensure the webhook captures all relevant Stripe events.
   - Click **Add Endpoint** to save.

4. **Environment Configuration**:
   - Add the following keys to your hosting environment variables (e.g., Heroku):
     - `STRIPE_PUBLIC_KEY`
     - `STRIPE_SECRET_KEY`
     - `STRIPE_WEBHOOK_SECRET` (found in the webhook details on Stripe).

5. **Test the Integration**:
   - Use Stripe’s **Test Mode** to verify that the payment process and webhook functionality are working as expected before switching to live mode.

---

By completing these steps, Stripe will be fully integrated with your project, allowing secure payment processing and seamless communication between your website and the Stripe platform.

#### Email Server Configuration

1. **Update the Django Settings**:
   Add the following configuration to your settings.py file:
   

```python
   EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
   EMAIL_HOST = "smtp.ethereal.email"
   EMAIL_PORT = 587
   EMAIL_USE_TLS = True
   EMAIL_HOST_USER = config('EMAIL_HOST_USER')
   EMAIL_HOST_PASSWORD = config('EMAIL_HOST_PASSWORD')
   DEFAULT_FROM_EMAIL = config('DEFAULT_FROM_EMAIL')
```

#### Environment Variables

Add the following variables to your environment configuration (e.g., `.env` file or hosting platform):

- `EMAIL_HOST_USER`: Your Ethereal email address.
- `EMAIL_HOST_PASSWORD`: Your Ethereal email password.
- `DEFAULT_FROM_EMAIL`: The default "From" email address for outgoing messages (e.g., `noreply@yourdomain.com`).

#### Testing the Email System in the Bash Terminal

Follow these steps to test the email system directly from the Django shell:

1. **Run the Django Shell**:
   - Open your terminal and start the Django shell by running:

````bash
     python manage.py shell
````
     

2. **Send a Test Email**:
   - Use the following commands in the Django shell to send a test email:

````python
     from django.core.mail import send_mail
     
     send_mail(
         'Test Email',  # Subject
         'This is a test email from the Django application.',  # Message body
         'noreply@yourdomain.com',  # From email (must match DEFAULT_FROM_EMAIL)
         ['recipient@example.com'],  # To email
         fail_silently=False,
     )
````

3. **Verify the Output**:
   - If the email is sent successfully:
     - The command will complete without any errors.
     - Check your Ethereal inbox to verify the email was received.
   - If there are errors:
     - Review the error message in the terminal.
     - Ensure your email server configuration and credentials are correct in both `settings.py` and your environment variables.

---

#### Notes for Testing

- **Ethereal Email Testing**:
  - Emails sent via Ethereal are only visible within the Ethereal testing environment.
  - Log in to your Ethereal account to check the email content and headers.

- **Testing in Development**:
  - It is recommended to test in **development mode** before deploying to ensure the configuration is working properly.

- **Production Testing**:
  - Once you replace Ethereal with a production email provider (e.g., Gmail, SendGrid), re-run these tests to confirm the new configuration is functional.

### Deployment to Heroku

Before deploying the application to Heroku, the following steps must be completed to ensure proper configuration:

---

#### Pre-Deployment Checklist

1. **Create a `Procfile`**:
   - The `Procfile` is used to configure the Gunicorn server and must be located in the root directory of the project.
   - Add the following line to the `Procfile`:
     ```plaintext
     web: gunicorn main.wsgi
     ```

2. **Generate a `requirements.txt` File**:
   - The `requirements.txt` file contains a list of dependencies required to run the project.
   - Generate it using the following terminal command:
     ```bash
     pip3 freeze > requirements.txt
     ```

---

#### Steps to Deploy the Application on Heroku

1. **Create a Heroku Account**:
   - Visit [Heroku](https://www.heroku.com/) to create an account or log in to an existing one.

2. **Create a New App**:
   - From the Heroku dashboard, click **Create New App**.
   - Enter a unique name for your app and select your region.
   - Click **Create App** to proceed.

3. **Configure Environment Variables**:
   - On the app homepage, go to the **Settings** tab.
   - Scroll down to the **Config Vars** section and click **Reveal Config Vars**.
   - Add the following environment variables:
     - `PORT`: Set the value to `8000`.
     - Add all other variables from your local `.env` file (e.g., `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `STRIPE_PUBLIC_KEY`, `STRIPE_SECRET_KEY`, etc.).

4. **Connect to GitHub**:
   - Go to the **Deploy** tab on the app homepage.
   - Under **Deployment Method**, select **GitHub**.
   - Click **Connect to GitHub** and authorize Heroku if prompted.
   - Use the search bar to find your GitHub repository.
   - Click **Connect** to link the Heroku app to your repository.

5. **Deploy the Application**:
   - At the bottom of the **Deploy** section, choose a deployment method:
     - **Automatic Deployment**: Automatically deploys new changes pushed to the main branch.
     - **Manual Deployment**: Click **Deploy Branch** to deploy the app manually.
   - Wait for the deployment process to complete.

6. **Launch the Application**:
   - Once the deployment is successful, click **Open App** to launch the live application.

---

#### Notes

- **Debugging**:
  - Ensure the `DEBUG` setting in your `settings.py` file is set to `False` in production.
  - Test all configurations locally before deploying.
  
- **Additional Configurations**:
  - If using a PostgreSQL database or AWS services, verify all environment variables and connections.

By following these steps, your application will be successfully deployed to Heroku and accessible online.

### Local Deployment

### How to Fork the Repository

To fork this repository:

1. Log in to or sign up at [GitHub](https://github.com/).
2. Navigate to the repository for this website.
3. Click the **Fork** button in the upper-right corner of the repository page.

---

### How to Clone the Repository

To clone this repository:

1. Log in to or sign up at [GitHub](https://github.com/).
2. Navigate to the repository for this website.
3. Click the green **Code** button in the upper-right corner of the repository page.
4. Copy the repository URL using the **Copy** button.
5. Open your terminal or IDE terminal and navigate to the directory where you want to clone the repository.
6. Type the following command in the terminal:
   ```bash
   git clone <repository_url>
   ```
7. Replace `<repository_url>` with the URL you copied.
8. Navigate to the project directory and install the required dependencies:
   ```bash
   pip3 install -r requirements.txt   
9. Add an `env.py` file containing the required environment variables. The variables should include:

   - `DATABASE_URL`: The URL for your PostgreSQL database.
   - `EMAIL_HOST_USER`: Your email address for the SMTP server.
   - `EMAIL_HOST_PASS`: Your email password for the SMTP server.
   - `SECRET_KEY`: Your Django secret key.
   - `STRIPE_PUBLIC_KEY`: Your Stripe public key.
   - `STRIPE_SECRET_KEY`: Your Stripe secret key.
   - `STRIPE_WH_SECRET`: Your Stripe webhook secret.

   Example of an `env.py` file:
   ```python
   import os

   os.environ["DATABASE_URL"] = "your_database_url"
   os.environ["EMAIL_HOST_USER"] = "your_email"
   os.environ["EMAIL_HOST_PASS"] = "your_email_password"
   os.environ["SECRET_KEY"] = "your_secret_key"
   os.environ["STRIPE_PUBLIC_KEY"] = "your_stripe_public_key"
   os.environ["STRIPE_SECRET_KEY"] = "your_stripe_secret_key"
   os.environ["STRIPE_WH_SECRET"] = "your_stripe_webhook_secret"
   ```

---

## Validation, Testing and Bugs

### Validation

To ensure Python files (.py extensions) are PEP8 valid, the following protocol was followed:

1. Installing Black (`$ pip install black`)
2. Update requirements (`$ pip freeze >> requirements.txt`)
3. Run Black (`$ black .`)
4. Run Black to format Python files with a specific line length of 79 characters (`$ black --line-length 79 .`)
5. Manual check all .py files with CI Python Linter. I created `list_py_files.py` to extract the file names of all .py files in the project and tested it only on the files I worked on.

#### CI Python Linter Screenshot

INSERT Screenhot

### Codebase Cleanup

As part of maintaining a clean and organized codebase, the following files were removed:

- `analytics/tests.py`
- `analytics/views.py`
- `bag/admin.py`
- `bag/models.py`
- `bag/tests.py`
- `checkout/tests.py`
- `contact/tests.py`
- `home/admin.py`
- `home/models.py`
- `home/tests.py`
- `pages/admin.py`
- `pages/models.py`
- `pages/tests.py`
- `products/tests.py`
- `profiles/admin.py`
- `profiles/tests.py`

#### Reason for Deletion

It is a good practice to regularly review the project's codebase and remove files that are not contributing to its current functionality. This not only maintains code quality but also ensures that future developers can easily understand and contribute without confusion. Keeping the project clean is key to scalability and maintainability. The rationale behind the removal includes:

1. **Unused Files**: The deleted files were either not used in the project or became redundant as functionality changed during development. Keeping unused files adds unnecessary clutter and makes the codebase harder to maintain and navigate.

2. **Improved Readability**: Removing redundant files significantly improves the readability of the project structure, allowing developers to quickly identify essential components without encountering irrelevant or confusing files.

3. **Reduced Technical Debt**: Actively managing and cleaning the codebase helps reduce technical debt, which ultimately contributes to better project health, maintainability, and long-term sustainability.

4. **Enhanced Collaboration**: A clean project with no unused or redundant files makes it easier for other developers to understand the purpose of each file. This is particularly beneficial when multiple developers are working on the project, as it ensures a shared understanding and reduces the likelihood of duplicated efforts or confusion.

---

## Credits

### Copy

### Imagery

### Code / Tutorials

### Acknowledgements




Running notes

Customise admin to make it more user friendly

list_filter: Adding filters for category and is_active allows you to quickly narrow down products by their category or active status.
search_fields: Adding search_fields for name and sku enables quick searches, making it easier to locate specific products.
ordering: Keeping the ordering by SKU or any other relevant field provides consistency in the display order.

Discount price 

    Conditionally Displayed Prices:
        If product.discount_price exists, the original product.price is displayed with a strikethrough (text-decoration: line-through;) and muted color.
        The discounted price (product.discount_price) is highlighted in a bold, different color (e.g., text-danger for red in Bootstrap).
    Fallback:
        If there’s no discount_price, only product.price is displayed normally.

Q

f request.GET:
        if 'q' in request.GET:
            query = request.GET['q']
            if not query:
                messages.error(request, "You didn't enter any search criteria!")
                return redirect(reverse('products'))
            
            queries = Q(name__icontains=query) | Q(description__icontains=query)
            products = products.filter(queries)

    context = {
        'products': products,
        'search_term': query,
    }

Summary: Implementing effective_price for Custom Sorting

To allow products to be sorted by price while prioritizing discount_price over the original price, we implemented the following steps:

    Annotated the Queryset:
        We used Django’s annotate method to dynamically create an effective_price field. This field checks if a discount_price exists for a product and uses it; otherwise, it defaults to the regular price.
        This was achieved using Case and When expressions:

    products = products.annotate(
        effective_price=Case(
            When(discount_price__isnull=False, then=F('discount_price')),
            default=F('price'),
        )
    )

Updated the Sorting Logic:

    In the all_products view, we modified the sort parameter to support effective_price. If the user selects to sort by price, the view orders the products by the annotated effective_price field, ascending or descending based on the direction parameter.

Adjusted Template Links:

    We updated the href attributes of the dropdown links in the template to use effective_price for sorting. For example:

        <a href="{% url 'products' %}?sort=effective_price&direction=asc" class="dropdown-item">By Price</a>

    Handled Sorting Directions:
        We incorporated the direction parameter to allow both ascending (asc) and descending (desc) sorting by effective_price.

    Tested Functionality:
        We verified that products with a discount_price appear in the correct order (sorted by discount_price first) and fallback to the original price when no discount_price exists.

Benefits:

    This approach ensures that discounts are prioritized during sorting, providing a better user experience for customers looking for the most relevant price.
    It is dynamic, leveraging Django’s ORM to handle complex logic without requiring changes to the database schema.

This functionality is fully integrated into the existing filtering and sorting system.

Sorting 

Sorting Functionality: This project includes a JavaScript-powered dynamic sorting feature. When a user selects an option from the sorting dropdown, the page automatically updates to reflect their choice. The script updates the URL query parameters (sort and direction) based on the selection and reloads the page with the new parameters.

This ensures a seamless and user-friendly way to filter and sort products by criteria like price, rating, or name. Additionally, the "Reset" option clears all sorting parameters and reloads the default product list.

Pricing and Discount Logic Implementation

To enhance the shopping bag functionality, we implemented a system to dynamically handle both regular and discounted product prices. Here’s a summary of what we did:

    Dynamic Price Calculation:
        Updated the bag_contents function to determine an effective_price for each product, prioritizing the discount_price if available, and falling back to the regular price otherwise.
        Calculated the subtotal for each item based on its quantity and effective_price.

    Template Adjustments:
        Updated the shopping bag template to display the effective_price for each product and the calculated subtotal dynamically.
        Ensured that the totals and subtotals were formatted correctly and reflected discounts when applicable.

    Validation Logic:
        Ensured that the discount_price field in the database is always less than the price to maintain data integrity.

    User Experience:
        Provided dynamic updates in the bag to reflect accurate pricing, ensuring customers see discounts applied correctly.

This implementation ensures accuracy and clarity in the pricing displayed to customers, enhancing the overall user experience.

Handling Perrume Sizes in the Shopping Bag

The shopping bag functionality includes a robust solution for handling products with size variations. By dynamically checking whether a product has a size attribute before attempting to use it, the implementation prevents errors when sizes are not applicable. This approach ensures:

    Flexibility for Different Product Types: The code accommodates both products with sizes (e.g., clothing or shoes) and those without sizes (e.g., accessories or generic items), making it versatile for diverse product catalogs.
    Error Prevention: By using item_data.get('size') to check for size information in the session data, the implementation avoids the NameError issue when a size is not provided or required.
    User-Friendly Experience: Users can add products to their bag seamlessly, whether the products include size options or not, ensuring a smoother shopping experience.

This dynamic handling of size data ensures the shopping bag logic remains error-free, adaptable, and capable of supporting a wide range of product configurations.

Quanity input script

This JavaScript snippet provides dynamic management of product quantity inputs in the shopping bag. It ensures a smooth and user-friendly experience by:

    Range Enforcement:
        Prevents the quantity from going below 1 or above 99 by disabling the - (decrement) and + (increment) buttons when the limits are reached.

    Page Load Handling:
        Automatically checks and adjusts the state of the - and + buttons for all quantity inputs when the page loads.

    Dynamic Updates:
        Listens for changes in quantity inputs and updates the state of the - and + buttons accordingly.

    Increment and Decrement Controls:
        Allows users to increment or decrement the quantity using buttons. The current value is updated dynamically in the input field, and button states are adjusted.

Why This is Useful

This script enhances usability by preventing invalid quantities and provides immediate feedback through button state changes. It improves the shopping experience by making quantity adjustments seamless and intuitive.

Approach to Subtotal Calculation

In this project, the subtotal for each item in the shopping bag is calculated in the context.py file rather than using a custom Django template filter, as some implementations suggest. This decision was made for the following reasons:

    Centralized Business Logic: Calculating the subtotal in context.py keeps all shopping bag-related logic in one place, making the codebase more maintainable and easier to debug.

    Simpler Templates: By precomputing the subtotal, the templates only need to display the values passed in the context. This avoids adding unnecessary logic or filters to the templates, adhering to Django's philosophy of keeping templates simple and focused on presentation.

    Efficiency: Computing the subtotal in the context avoids redundant calculations in the template rendering process, ensuring the application runs more efficiently, especially for large bags or complex templates.

    Flexibility: Passing precomputed values like subtotal to the context allows for easier customization in the future, such as adding taxes, discounts, or other price adjustments.

This approach reflects a clean separation of concerns between business logic and presentation, ensuring the project remains scalable and maintainable.

Issue: Toast Messages Displayed Incorrect Information

Issue: Toast Messages Displayed Incorrect Information

In the initial implementation, toast messages displayed incorrect or unclear information when users added, updated, or removed items from the shopping bag. Specifically, the messages referenced raw data from the session (e.g., item IDs or quantities) instead of meaningful details like the product's name. This caused confusion for users as they were shown numbers instead of the actual product names.
Fix: Improved Toast Messaging

The messages framework was updated to dynamically include the product's name and relevant details (e.g., size and quantity) in all user feedback. This involved:

    Fetching the product name from the database (Product.objects.get(pk=item_id)).
    Updating success and warning messages to use clear, user-friendly text.
    Including size and quantity details where applicable for better context.

This fix ensures that all toast messages provide accurate and meaningful feedback, enhancing the user experience. For example:

    Before: Updated quantity to 2.
    After: Updated 'Product Name' quantity to 2.

Relevant Files

    views.py: Adjusted logic for add_to_bag, adjust_bag, and remove_from_bag to include meaningful details in toast messages.

Admin Panel Enhancements for the Checkout App

We improved the admin.py file for the checkout app to enhance the usability and efficiency of the admin interface. Here’s a summary of the improvements:
Original Code:

    The initial implementation included basic inline editing for OrderLineItem and read-only fields for Order totals, such as order_total and grand_total.
    While functional, it lacked features like search, filtering, and formatted display of key information, making order management less efficient.

Improvements:

    Search Functionality:
        Added the search_fields attribute to enable admins to search orders by key attributes such as:
            order_number
            full_name
            email
            phone_number

    Benefit: Speeds up locating specific orders in the admin panel.

search_fields = ('order_number', 'full_name', 'email', 'phone_number')

Filtering Options:

    Introduced list_filter to filter orders by:
        date
        country
        grand_total

Benefit: Helps admins quickly narrow down orders based on criteria like date or order value.

list_filter = ('date', 'country', 'grand_total')

Improved Display of Totals:

    Created a custom method formatted_grand_total to format grand_total as currency for better readability.

Benefit: Admins can now see monetary totals in a user-friendly format.

def formatted_grand_total(self, obj):
    return f"${obj.grand_total:,.2f}"
formatted_grand_total.short_description = 'Grand Total'

Aggregate Total Items:

    Added the total_items method to display the total quantity of items in an order.

Benefit: Admins can easily see how many items were purchased in each order without opening individual line items.

def total_items(self, obj):
    return obj.lineitems.aggregate(Sum('quantity'))['quantity__sum'] or 0
total_items.short_description = 'Total Items'

Enhanced Inline Editing:

    Improved the OrderLineItemAdminInline to show:
        product
        product_size
        quantity
        lineitem_total

Benefit: Provides more context for line items directly in the order view.

readonly_fields = ('product', 'product_size', 'quantity', 'lineitem_total')

Ordering Improvements:

    Updated the ordering attribute to sort by:
        date (descending)
        order_number (secondary sorting)

Benefit: Maintains a logical order for viewing recent orders while ensuring consistency.

    ordering = ('-date', 'order_number')

Final Code:

The final implementation is a more user-friendly and efficient admin panel that supports:

    Search functionality
    Filtering by key attributes
    Aggregated and formatted totals
    Enhanced inline editing for order line items

These changes improve admin productivity and simplify the management of orders in the application.

mprovements to the Checkout Form

The original OrderForm provided basic functionality for capturing user data during the checkout process. We made several enhancements to improve usability, accessibility, and data validation. Here’s an overview of the improvements:
Original Code:

    Dynamically set placeholders for each field.
    Added CSS classes for consistent styling with Stripe.
    Hid labels for a cleaner design.
    Automatically focused on the full_name field.

Improvements Made:

    Improved Field Accessibility:
        Explicitly defined input types for email and phone_number fields to enhance usability and improve validation in the browser.

    self.fields['email'].widget.attrs['type'] = 'email'
    self.fields['phone_number'].widget.attrs['type'] = 'tel'

Benefit: This helps users enter valid data and ensures fields are tailored for their purpose, improving the overall user experience.

Enhanced Placeholder Management:

    Kept the dynamic placeholders but ensured consistency for required fields by appending an asterisk (*).

    if self.fields[field].required:
        placeholder = f'{placeholders[field]} *'

Benefit: This visually indicates required fields without relying on labels.

Optional Country Field Improvements:

    Suggested enhancements for the country field to either:
        Use django-countries for pre-defined country choices.
        Or, explicitly define dropdown options using a ChoiceField.

Benefit: This ensures that the country field is more structured and user-friendly.

Maintained Autofocus on the First Field:

    Retained autofocus for the full_name field, ensuring that users are immediately directed to start entering their information.

Benefit: Streamlines the checkout process and minimizes user effort.

Validation Suggestions:

    Recommended adding validation for specific fields, such as checking for numeric-only phone numbers:

        def clean_phone_number(self):
            phone_number = self.cleaned_data.get('phone_number')
            if not phone_number.isdigit():
                raise forms.ValidationError('Phone number must contain only digits.')
            return phone_number

    Benefit: Helps maintain clean and valid data in the database.

    Code Readability and Maintainability:
        Cleaned up the code for easier understanding and maintenance. For example, grouped enhancements logically and added comments for clarity.

Final Outcome:

The improved OrderForm is more robust, user-friendly, and accessible. These enhancements:

    Improve the user experience by guiding users with appropriate input types and placeholders.
    Support accessibility and responsiveness by hiding labels while ensuring fields remain intuitive.
    Provide a foundation for future improvements, such as dropdowns for countries or advanced validation rules.

Issue with JavaScript and Why CSS Was Used

Initially, JavaScript was implemented to manage custom increment and decrement buttons for quantity input fields. While it successfully controlled these buttons and enforced value limits, it did not disable or hide the browser's default spinner arrows for type="number" input fields. These spinner arrows are a built-in feature of modern browsers and are not directly addressed by JavaScript without additional logic, such as altering the input type or blocking arrow key events. However, such approaches add complexity and may lead to inconsistent behavior across different browsers.

To resolve this, CSS was used to hide the spinner arrows. This solution is simpler, cleaner, and more reliable, as it directly targets the browser-specific pseudo-elements responsible for rendering the spinners. By using CSS, the UI was streamlined without compromising functionality, allowing the custom buttons to handle all user interactions seamlessly.


{% if grand_total and not on_profile_page %} profile app p6

Pre-Filled Read-Only Fields for Logged-In Users

The contact form now includes a feature that automatically pre-fills the "Name" and "Email" fields for logged-in users. These fields are set to read-only, ensuring that user information remains consistent and cannot be altered unintentionally. This enhancement improves user experience by streamlining the form submission process while maintaining data integrity. The fields are visually greyed out to indicate they are non-editable, providing clear feedback to users.

Updates and Fixes for Stripe Webhooks (Nov 14, 2024)
Overview

This morning's work focused on refining the Stripe webhook handler to address several critical issues related to order processing, inventory management, and admin functionality. These changes ensure a smoother user experience and improve backend accuracy.
Key Issues Addressed

    Duplicate Order Line Items in Admin:
        Fixed a bug where order line items were being duplicated in the admin interface.
        Ensured that existing line items are updated instead of creating duplicates when processing orders.

    Inventory Management:
        Resolved a critical issue where stock quantities were not being reduced correctly after order creation.
        Implemented logic to accurately adjust stock levels for products, whether they are standard items or have specific sizes.

    Order Line Item Quantities:
        Updated logic to ensure the quantity of existing order line items is reset to the correct value, avoiding unintended accumulation.

    User Profile Handling:
        Improved handling of user profiles to update saved shipping information only when explicitly requested by the user.

    Logging and Debugging:
        Added detailed print statements and logging to track inventory updates and order processing in real-time, facilitating debugging and improving transparency.

Steps Taken

    Refactored _update_inventory Method:
        Centralized logic for handling product stock updates and order line item creation.
        Used get_or_create for order line items to handle both new and existing entries, updating quantities as needed.

    Improved Stock Adjustments:
        Ensured that product stock is reduced only once per order, with accurate calculations for single items and items with sizes.

    Enhanced Webhook Logic:
        Implemented robust error handling and rollback mechanisms to prevent partial orders or incorrect inventory updates.
        Ensured that emails are sent to users only after all processing steps are successful.

    Manual Testing:
        Conducted thorough manual testing to verify fixes:
            Placed orders with varying quantities.
            Confirmed correct stock adjustments.
            Checked admin interface for proper order line item behavior.

Results

    Bug-Free Admin Experience: Admins now see accurate order line items without duplication.

    Accurate Inventory Management: Product stock updates correctly reflect user purchases, ensuring inventory integrity.

    Improved User Experience: Users receive accurate order confirmations with proper details.

Future Improvements

    Unit Tests: Add automated tests for webhook handling and inventory updates to catch edge cases.
    Error Notifications: Implement email or logging notifications for critical webhook errors.
    Optimized Logging: Replace verbose logs with more structured and configurable logging.

This update ensures that the Stripe webhook handler is more reliable, scalable, and user-friendly. All fixes have been committed to the repository and tested extensively.

Review feature

Implementation Details
1. Database Structure

    Models:
        Product: Modified to calculate the average rating dynamically from associated reviews.
        Review: New model that stores product, user, rating, and comment. It includes a unique_together constraint to ensure a user can only review a product once.

2. Views

    Added views for the following operations:
        add_review: Displays a form to add a review.
        edit_review: Allows users to modify an existing review.
        delete_review: Displays a confirmation page and deletes the review upon confirmation.

3. Templates

    Created three templates:
        Add Review: Provides a user-friendly form with radio buttons for rating selection.
        Edit Review: Displays the pre-filled form for review editing.
        Delete Review: Confirmation page showing the review details before deletion.

4. Forms

    Created ReviewForm for adding and editing reviews.
    Enhanced the rating field with radio buttons for intuitive selection.

5. URL Routing

    Updated products/urls.py to include routes for:
        Adding a review: products/<product_id>/reviews/add/
        Editing a review: products/<product_id>/reviews/<review_id>/edit/
        Deleting a review: products/<product_id>/reviews/<review_id>/delete/

6. Admin Integration

    Updated the admin panel to manage reviews effectively:
        Included Review in the admin panel.
        Added inline editing of reviews under the product management interface.

7. Front-End Integration

    Updated the product detail page to include:
        A review section with:
            User reviews displayed in a styled list.
            Buttons for editing and deleting reviews for the respective user.
        A "Write a Review" button if the user hasn’t reviewed the product yet.

User Flow

    Viewing Reviews:
        Users navigate to a product detail page and see existing reviews and overall product rating.
    Adding a Review:
        If a user hasn’t reviewed the product, they can click "Write a Review," fill out the form, and submit.
    Editing a Review:
        Users click "Edit" on their review, modify the details in the pre-filled form, and save changes.
    Deleting a Review:
        Users click "Delete" on their review, confirm the deletion, and remove it permanently.

Validation and Security

    Users can only edit or delete their own reviews.
    Review input is validated to ensure the rating is within 0-5 and comments are optional but encouraged.
    CSRF tokens are implemented for all forms to prevent cross-site request forgery attacks.

Benefits of the Review Functionality

    Encourages customer engagement and feedback.
    Helps potential customers make informed purchasing decisions by reading authentic reviews.
    Provides a clear and transparent mechanism for gathering product feedback.

This feature is a robust addition to the platform, enhancing both user experience and product discoverability.

Dynamic Product Rating System

The product rating system has been enhanced to dynamically calculate and update the average rating based on user reviews. This ensures that the displayed rating is always accurate and reflects real user feedback.
Key Features:

    Real-time Updates: The product's average rating updates dynamically whenever a review is added, edited, or deleted.
    Integration with Admin Panel: The updated rating is displayed in the Django admin interface for better product management.
    Automatic Calculation: The average rating is calculated using Django signals (post_save and post_delete), ensuring seamless updates without manual intervention.

Technical Implementation:

    Signals Setup:
        A post_save signal was implemented to update the product's rating whenever a review is saved.
        A post_delete signal recalculates the rating when a review is deleted.

    Model Adjustments:
        The rating field in the Product model is marked as editable=False to enforce that it is calculated dynamically.

    App Configuration:
        The signals.py file is loaded in the ready method of the ProductsConfig class.

How It Works:

    When a review is created, updated, or deleted, the product's update_rating method is triggered via signals.
    The method calculates the average rating based on all associated reviews.
    The calculated rating is saved to the rating field in the Product model.

Benefits:

    Ensures the product rating reflects genuine user feedback in real-time.
    Reduces manual workload for administrators.
    Enhances user trust by displaying accurate product ratings.

README Update
Preventing Duplicate Reviews

This update improves the review system by ensuring that users can submit only one review per product. Duplicate reviews were previously causing database integrity errors due to unique constraints on the Review model. By adding custom validation to the ReviewForm and updating the add_review view, this fix ensures:

    A smoother user experience by informing users they have already reviewed the product.
    Robust backend validation to avoid crashes or errors if a duplicate review is attempted.
    Flexibility for users to edit their existing reviews instead of submitting multiple entries.

This enhancement improves application stability and ensures fair and clean review management for all users.

README Update: Dynamic Tab Title Feature
Dynamic Tab Titles for Improved User Engagement

The dynamic tab title feature is designed to enhance user retention and engagement by changing the browser tab's title when a user navigates away. This subtle reminder can help draw users back to your site, which is particularly valuable for e-commerce platforms where attention and retention are critical to increasing conversions.
How It Works

    Visibility Detection: The feature leverages the visibilitychange event, which detects when a browser tab becomes hidden (inactive) or visible (active).
    Title Change: When the tab is hidden, the page title changes to a predefined message (e.g., "Come back soon! 🛍️"). When the user returns to the tab, the original title is restored.

Code Implementation

The functionality is implemented in a separate JavaScript file for modularity and ease of maintenance.

// Save the original title
let originalTitle = document.title;

// Listen for visibility change events
document.addEventListener("visibilitychange", function () {
    if (document.hidden) {
        // Change the title when the tab is inactive
        document.title = "Come back soon! 🛍️";
    } else {
        // Restore the original title when the tab is active again
        document.title = originalTitle;
    }
});

This script is stored in static/js/dynamic_title.js and included site-wide through the base.html template:

{% block extra_js %}
    <script src="{% static 'js/dynamic_title.js' %}"></script>
{% endblock %}

Why This Feature Is Useful

    Improved Retention: Reminds users to return to your site, reducing the chances of them forgetting or abandoning their session.
    Increased Conversions: Helps bring users back to their shopping cart or browsing session, potentially boosting sales.
    Subtle and Non-Intrusive: Does not disrupt the user experience and only displays a message when the user leaves the tab.
    Engaging Messaging: Allows creative and personalized messages, such as "Don’t forget your cart!" or "We miss you already!"

By implementing this feature, your e-commerce site can stay top-of-mind for users and encourage them to re-engage, fostering better retention and conversion rates.

README Update: Adding Confirmation Modals
What We Did

We implemented confirmation modals for deleting products and reviews in the application. These modals are triggered when a user (e.g., a superuser or the review owner) clicks the "Delete" button. Each modal displays a clear message asking the user to confirm their action, with options to either cancel or proceed with the deletion.

    Product Deletion Modal:
        Used in the product details page, specifically for superusers.
        Ensures that deleting a product is intentional.
    Review Deletion Modal:
        Associated with individual reviews in the review section.
        Allows review owners to confirm before deleting their own reviews.

How It Works

    The modals are built using Bootstrap and include:
        A warning message to inform users about the irreversible nature of the action.
        A "Cancel" button to close the modal without taking action.
        A "Delete" button to proceed with the deletion.

    Each modal is dynamically linked to the respective product or review, ensuring the correct item is targeted for deletion.

Why This Improves the Code

    Enhanced User Security:
        Prevents accidental deletions by requiring explicit confirmation from the user.

    Better User Experience:
        Provides clear, non-intrusive feedback to the user before performing critical actions.
        Streamlines the interaction by avoiding unnecessary redirects or reloads for cancellation.

    Dynamic and Scalable:
        The modals are dynamically linked to the respective data (products or reviews), making the solution scalable for multiple items.

    Cleaner UI:
        Maintains a consistent and professional design, aligning with modern web application standards.

This update significantly improves the usability and reliability of deletion functionalities, ensuring that critical actions are always intentional and clear to the user.

Product Review Section Summary

We enhanced the product review section to improve its functionality and user experience. Key updates include:

    Write a Review Button:
        Added a conditional "Write a Review" button visible only to authenticated users who have not yet reviewed the product.
        Users who have already submitted a review see a message indicating so, and unauthenticated users are prompted to log in.

    Review Separation:
        Introduced horizontal lines (<hr>) to visually separate each review, making the layout cleaner and more readable.

    Delete Confirmation Modals:
        Added modals for confirming review deletions, ensuring users cannot accidentally delete reviews without confirmation.

These updates provide a more intuitive and polished interface, aligning with modern e-commerce standards.

Critical Update: SKU Uniqueness Enforcement
Description

In this update, we added a unique constraint to the sku field in the Product model. This ensures that each product has a distinct SKU, a critical identifier used for inventory management, sales tracking, and integration with third-party systems.
Reason for the Change

Previously, the application allowed duplicate SKUs, which led to issues such as:

    Inventory Management Conflicts: Multiple products with the same SKU made it difficult to track stock levels accurately.
    System Integration Errors: Many external systems and APIs (e.g., payment processors, shipping systems) rely on SKU as a unique identifier. Duplicate SKUs caused data mismatches and operational failures.
    User Confusion: Both admin users and customers faced difficulty distinguishing between products with the same SKU.

How the Issue Was Addressed

    Existing Data Cleanup:
        Duplicate SKUs in the database were identified and resolved by appending unique identifiers to affected SKUs.
    Database Schema Update:
        A unique=True constraint was added to the sku field in the Product model to enforce SKU uniqueness at the database level.
    Validation Logic:
        Additional validation was introduced in the model to ensure programmatically created or updated products adhere to the uniqueness rule.

Impact

This change ensures the integrity and reliability of product data, improves system stability during integrations, and enhances the user experience for both admins and customers.

Hero Section

The homepage now features a visually appealing Hero Section designed to engage users immediately upon landing on the site. This section includes:

    Full-Width Hero Image: A dynamic image covering the width of the viewport to create an immersive experience.
    Overlay Design: A semi-transparent overlay ensures the text is legible while maintaining the image's visual impact.
    Structure for Content: The hero section is structured to include a prominent heading, subheading, and a call-to-action button.

Code Highlights:

    HTML:
        Hero section defined with div containers for image and overlay.
        Placeholder for headings and a "Shop Now" button for user engagement.

        Future Enhancements:

    Dynamic Messaging: Add text transitions for marketing messages.
    Interactive Button: Enhance the "Shop Now" button with hover effects or animations.
    Responsive Design: Optimize the hero section for smaller screens and devices.

This feature sets the stage for a visually engaging and user-friendly e-commerce experience.

README Update
About Page Enhancements

The About page was updated with scoped styles to prevent conflicts with global styles from the base CSS. By introducing a unique wrapper class (.about-page), all styles for the About page are isolated and apply exclusively to this page. This approach ensures:

    Modular Design: Scoped styles for better maintainability.
    Conflict Resolution: Avoids overriding global styles like .hero-section.
    Improved Readability: Easier to locate and modify About page styles.

Key updates include:

    Scoped styles for the hero section, profile image, and other page components.
    Adjusted HTML structure by adding a .about-page wrapper for consistent style application.
    Ensured responsive and clean layout across different devices.

This change aligns with modern CSS practices, improving scalability and maintainability of the project.

Explanation of the Code:

    Imports:
        The necessary models (Product, SalesData) and Django functions like render, random.sample, and Count are imported.

    Product Querying:
        new_in_products: Fetches the 4 most recently added active products from the last 30 days.
        for_him_products: Fetches the 4 most recent men's products (gender='M').
        for_her_products: Fetches the 4 most recent women's products (gender='W').
        most_popular_products: Uses Count to annotate products with their total views from the SalesData model and orders by views in descending order.
        highest_rated_products: Fetches the 4 highest-rated active products by rating.
        random_products: Selects 4 random products from the database.

    Context:
        The context dictionary passes all the product sections to the template (index.html) for rendering.

    Rendering the Template:
        The render() function returns the context to index.html, where it will be displayed.

Final Notes:

    The home view aggregates products for different sections based on various criteria like creation date, gender, views, ratings, and randomness.
    The template (index.html) is responsible for displaying these products in a user-friendly way across various sections.

Bug: humanize Filters Not Available in Templates
Issue Description

While implementing the humanize filters (e.g., intcomma), we encountered an issue where these filters were not globally available in templates, even when {% load humanize %} was added to the base.html file. This caused errors in child templates that extended base.html but relied on intcomma or other humanize filters.
Root Cause

Django's {% load %} tag is template-local, meaning it only applies to the file where it's explicitly loaded. Filters from django.contrib.humanize were therefore not propagated to child templates, leading to errors such as:

TemplateSyntaxError: Invalid filter: 'intcomma'

Solution

To resolve this issue, the django.contrib.humanize app was added to the builtins section in the TEMPLATES configuration in settings.py. This made the humanize filters globally available without requiring {% load humanize %} in individual templates.
Code Implementation

# settings.py
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [
            os.path.join(BASE_DIR, 'templates'),
        ],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
            'builtins': [
                'crispy_forms.templatetags.crispy_forms_tags',
                'crispy_forms.templatetags.crispy_forms_field',
                'django.contrib.humanize.templatetags.humanize',  # Added to ensure global availability of humanize filters
            ]
        },
    },
]

Why This Solution Was Chosen

    Global Availability: Filters like intcomma are frequently used across the project. Adding humanize to builtins eliminates the need for repetitive {% load humanize %} in every template.
    Maintainability: This approach simplifies the templates and avoids potential errors in new templates that rely on humanize.
    Minimal Overhead: The performance impact of adding humanize to builtins is negligible for most projects.

Considerations

While this solution is effective, it introduces implicit dependency on humanize being globally available. To mitigate this:

    A clear comment was added to settings.py to document this change.
    Developers are advised to check for potential naming conflicts with custom template filters.

Filtering Active Products
Problem:

Previously, the products view and template displayed all products in the database, including inactive ones. This was problematic as inactive products were not supposed to be visible to users.
Solution:

The all_products view was updated to filter products based on their is_active status. Only products where is_active=True are included in the query. This ensures that inactive products are excluded from the product listing and search results.
Implementation Details:

    View Changes:
        The Product.objects.all() query was modified to Product.objects.filter(is_active=True) in the all_products view.
        This ensures that only active products are annotated, sorted, and passed to the template.

    Template Logic:
        The template was not modified significantly, as it already relied on the products context variable passed from the view.
        The {{ products|length }} tag now reflects the count of active products only.

Benefits:

    User Experience: Users no longer see inactive products in listings, searches, or filters.
    Data Integrity: Aligns the frontend display with business logic, ensuring inactive products are not accessible.
    Maintainability: The filtering logic is centralized in the view, simplifying future updates or changes.

Example:

Before:

    Users would see all products, including inactive ones, in the product listing and search results.

After:

    Only active products (is_active=True) are displayed, ensuring that the product catalog remains up-to-date and accurate.

Commit Reference:

    Commit: "Filter products by active status in the all_products view to display only active products and update template logic to reflect the changes."

This update enhances the integrity and reliability of the product display on the site.

Sitemap Functionality

This project includes a dynamically generated XML sitemap using Django's built-in sitemap framework. The sitemap enhances SEO by providing search engines with structured information about the site's content, including product detail pages. The implementation includes:

    Centralized sitemap logic in sitemaps.py.
    URL routing for the sitemap at /sitemap.xml.
    Updates to the Product model to support dynamic URL generation. This ensures that the sitemap remains up-to-date as content changes, improving search engine indexing and discoverability.

    Robots.txt Implementation

This project includes a robots.txt file to guide web crawlers on which parts of the website can and cannot be accessed. The robots.txt is dynamically served using Django's TemplateView to allow flexibility in managing crawler access. Key sections such as the admin panel, user profiles, and checkout pages are restricted to protect sensitive data, while public pages are open for indexing to improve SEO. Additionally, GPTBot is explicitly blocked to prevent the use of site content in AI model training. The file also includes a reference to the sitemap for efficient indexing by search engines.

Dynamic Footer Year

The footer of the website dynamically displays the current year based on the user's local system clock. This ensures that the displayed year is always accurate and updates automatically.
Implementation Details

    The year is dynamically generated using JavaScript:

    new Date().getFullYear();

    A fallback mechanism is in place to display a hardcoded year (2024) if JavaScript is disabled on the user's browser.

Benefits

    Automation: No need for manual updates to the year.
    User-Centric: Reflects the user's local system time for accuracy.
    Accessibility: Ensures a visible year, even without JavaScript.

Pagination Benefits in E-Commerce

Implementing pagination on the products page is essential for enhancing user experience and ensuring optimal performance. Pagination prevents overwhelming users with an extensive list of products by displaying a manageable number of items per page. This approach improves load times, especially for users with slower internet connections, as it reduces the amount of data that needs to be retrieved and rendered at once. Additionally, by organising products across multiple pages, navigation becomes more intuitive and user-friendly, allowing customers to browse and locate their desired items efficiently. Pagination also plays a critical role in improving server performance, as it reduces the strain on database queries and enables faster responses. Overall, incorporating pagination ensures a seamless and enjoyable shopping experience for customers while maintaining the scalability of the platform.

Implementation of Stock Control
Overview

The stock control feature ensures that product inventory is accurately managed in real time during the checkout process. When a customer places an order, the system automatically deducts the purchased quantity from the product’s available stock, preventing overselling. If the stock is insufficient, the order cannot proceed.

This feature integrates seamlessly into the checkout and payment workflows, ensuring robust and reliable inventory management.
Key Features

    Real-Time Stock Deduction:
        Automatically deducts stock when an order is created.
        Ensures accurate inventory updates after successful payments.

    Stock Validation:
        Prevents orders from being placed if requested quantities exceed available stock.
        Raises appropriate error messages for insufficient stock.

    Error Handling:
        Ensures database consistency with transaction rollbacks in case of errors.
        Logs issues for easier debugging and monitoring.

    Admin Control:
        Allows administrators to view and update stock levels through the Django Admin panel.

How It Was Implemented

    Updating the Product Model:
        Added a stock_quantity field to track the available inventory for each product.
        Example:

    stock_quantity = models.IntegerField(default=0)

Stock Deduction in OrderLineItem:

    The save method of the OrderLineItem model was overridden to:
        Validate available stock before deducting.
        Deduct the purchased quantity from stock_quantity.
        Example:

        if self.product.stock_quantity < self.quantity:
            raise ValueError(f"Insufficient stock for {self.product.name}. Only {self.product.stock_quantity} left.")
        self.product.stock_quantity -= self.quantity
        self.product.save()

Integration into Checkout Process:

    Updated the checkout view to ensure stock adjustments are triggered through the line_item.save() method.
    Ensured consistency by routing all stock adjustments via the OrderLineItem.save() method.

Stripe Webhook Integration:

    In the webhook_handler.py, stock adjustments are performed for successful payments by creating OrderLineItem objects and calling save():

        line_item.save()  # Stock adjustment happens here

    Admin and Testing Enhancements:
        Included stock_quantity in the Django Admin for easy management.
        Added test cases to validate:
            Sufficient stock availability.
            Proper stock deduction after order creation.
            Errors for insufficient stock scenarios.

Testing

    Checkout Process:
        Tested the complete order workflow to ensure stock is deducted appropriately.
        Simulated edge cases such as ordering more than the available stock.

    Stripe Webhook:
        Used the Stripe CLI to trigger payment_intent.succeeded events and validated the stock adjustment logic.

    Error Handling:
        Verified that errors (e.g., insufficient stock) are logged and orders are rolled back.

Future Enhancements

    Order Cancellation:
        Replenish stock if an order is canceled.

    Low Stock Notifications:
        Add alerts for administrators when stock levels fall below a certain threshold.

    Concurrent Order Handling:
        Implement locks or other mechanisms to handle simultaneous orders for the same product.